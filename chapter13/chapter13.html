<!DOCTYPE html>
<html lang="en">

<head>
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
	<script> 
	$(function(){ // I use jQuery in this example
      
           function () { close(){$(".flip").click(function(){
    $(".panel").slideUp("slow");
  });
   });
   });
$(document).ready(function(){
  $(".flip").click(function(){
    $(".panel").slideToggle("slow");
  });
});
</script>
   

    <title>Chapter-13</title>
<link rel="stylesheet" href="css/style.css" type="text/css"/>
<style>
.list {list-style-type:none}
.list > li {display:inline;
			float:left;}
</style>
    <!-- Bootstrap Core CSS -->
    <link href="css/bootstrap.min.css" rel="stylesheet">

    <link href="css/agency.css" rel="stylesheet">


   
</head>

<body id="page-top" class="index">

    <!-- Navigation -->
    
<div class="header" style="background-image:url('head.jpg'); background-repeat:no-repeat; background-position:top;margin:0 auto;

	overflow:hidden;">
	<div class="wrap">
		<div style="">
		<center><h1><font size="100px"><a href="../index.html"><img src="intro.jpg"></a></font></h1><center>
		</div>
		<div class="cname" style="font-family: Arial black, Georgia, Serif">
			
         <center><h1><font type="Arial black">Chapter-13</h1></center>
		</div>	
		<div class="clear"><center><h2><font color="#346fa1">Red Trees</font></h2></center></div>
	</div>
</div>
   
 <div class="container" style="background-image:url('tail.jpg');background-repeat:no-repeat;background-position:top;margin:0 auto;

	overflow:hidden;margin-top:-50px">
    <section id="content" >
      <div class="inside">
        <br><br><center><h2>All Questions</h2></center>
        <div class="left" style="width:100%">
        <ul class="list"><br><br>
          <li style="margin-left:130px;width:23%"><img src="icon1.png">
            <h4><a href="#portfolioModal1" class="portfolio-link" data-toggle="modal">
                       Treap
                         </a></h4>
			

			<a href="treap.cpp" style="margin-top:-50px" download>Download</a>
            <br/>
			<br>
			<br/>
			<br>
          </li>
          <li style="width:23%"><img src="icon1.png">
            <a href=""><h4><a href="#portfolioModal2" class="portfolio-link" data-toggle="modal">Red Black Tree</a></h4></a>
            <a href="red_black.cpp" download>Download</a>
          <br/><br/>
			<br>
			<br>
		  </li>
          <li style="width:20%"><img src="icon1.png">
            <a href=""><h4><a href="#portfolioModal3" class="portfolio-link" data-toggle="modal">Red Black Tree Without Parent</a></h4></a>
            <a href="red_black_without_parent.cpp" download>Download</a>
			<br/><br/>
			<br>
			<br>
          </li>
	
        </ul>
      </div>
	  <div class="left" style="width:100%">
        <ul class="list">
          <li style="margin-left:130px;width:23%"><img src="icon1.png">
            <a href=""><h4><a href="#portfolioModal4" class="portfolio-link" data-toggle="modal">AVL Trees</a></h4></a>
			<a href="avl.cpp" style="margin-top:-50px" download>Download</a>
            <br/>
			<br>
			<br/>
			<br>
          </li>
          <li style="width:23%"><img src="icon1.png">
            <a href=""><h4><a href="#portfolioModal5" class="portfolio-link" data-toggle="modal">Persistent Trees</a></h4></a>
            <a href="persistent.cpp" download>Download</a>
          <br/><br/>
			<br>
			<br>
		  </li>
          <li style="width:23%"><img src="icon1.png">
            <a href=""><h4><a href="#portfolioModal6" class="portfolio-link" data-toggle="modal">sd</a></h4></a>
            <a href="sd.cpp" download>Download</a>
			<br/><br/>
			<br>
			<br>
          </li>
	
        </ul>
      </div>
	   </div>
	  <br/>
	  <br/>
	  <br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/>
	  	  <center><p class="lf">Copyright &copy;  <a href="http://www.httpcart.com/">httpcart.com</a> - All Rights Reserved</p>
    <p class="rf">A product of <a href="http://www.httpcart.com/">httpcart.com</a></p></center>

      </div>
    </section>
	
</div>
    
                
                  
                    
                
           
   


    <!-- Portfolio Modals -->
    <!-- Use the modals below to showcase details about your portfolio projects! -->

    <!-- Portfolio Modal 1 -->
	
    <div class="portfolio-modal modal fade" id="portfolioModal1" tabindex="-1" role="dialog" aria-hidden="true" >
        <div class="modal-content">
            <div class="close-modal" data-dismiss="modal">
                <div class="lr">
                    <div class="rl">
                    </div>
                </div>
            </div>
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-lg-offset-2">
                        <div class="modal-body">
                            <!-- Project Details Go Here -->
                             
                            <p class="item-intro text-muted">  <pre class='brush: cpp'>#include&ltiostream&gt
#include&ltvector&gt
#include&ltcmath&gt
#include&ltcstdlib&gt
#include&ltalgorithm&gt
#define null NULL
using namespace std;

struct node{
       int data;
       int priority;
       node* left;
       node* right;
       node* parent;
       };

class Treap{
      node* root,*nil;
      public:
             Treap(){nil=new node;nil->data=null;nil->left=null;nil->right=null;nil->parent=nil;nil->priority=0;root=nil;}
      
      void Left_Rotate(node *p){
           
      node *y=p->right;
      y->parent=p->parent;
           
           if(p->parent!=nil){if(p==(p->parent->left)){y->parent->left=y;}else{y->parent->right=y;}}
           else{root=y;}
        p->right=y->left;
        if(p->right!=nil) p->right->parent=p;
        y->left=p;
        p->parent=y;   
           
           }//left rotate close  
        
      void Right_Rotate(node *p){
           //cout&lt&lt" p right "&lt&ltp&lt&ltendl;
      node *y=p->left;
      y->parent=p->parent;
           
           if(p->parent!=nil){if(p==(p->parent->left)){y->parent->left=y;}else{y->parent->right=y;}}
           else{root=y;}
        p->left=y->right;
        if(p->left!=nil)p->left->parent=p;
        y->right=p;
        p->parent=y;   
        
          }//right rotate close  
        
        
      
      
      
      void Treap_Insert(int a){
           
           node *x=root,*y=nil;
           while(x!=nil){
                          y=x;
                          if(x->data>a){x=x->left;}
                          else{x=x->right;}
                          }
           node *temp=new node;
           temp->data=a;
           temp->left=nil;
           temp->right=nil;
           temp->parent=y;
           temp->priority=rand();
           if(temp->parent==nil){root=temp;}
           else{
                if(a&lty-&gtdata){ y->left=temp; }else{y->right=temp;}}
           
           
      x=temp;
      
      while(x!=root && x->priority<x->parent->priority){
                    if(x==x->parent->left){Right_Rotate(x->parent);}
                    else{Left_Rotate(x->parent);}
                    }
                    }//treap insert finish         
  
  
  node* Treap_Minimum(node *p){if(p->left!=nil){return Treap_Minimum(p->left);}else{ return p;}}//treapS minimun clccose
        

 node* Treap_Succesor(node* p){
           
           if(p->right!=nil){return Treap_Minimum(p->right);}
           node *y=p;
           while(y!=nil && y==(y->parent)->right){ y=y->parent;  }
           return (y==nil?nil:y->parent);
           }//treap succesor cllose
      

void Treap_Delete(node* p){
     
            node *y=nil;
            if(p->left==nil || p->right==nil){y=p;}
            else{y=Treap_Succesor(p);}
            node* x=nil;
            if(y->left!=nil){ x=y->left; }
            else{x=y->right;}
            
                     x->parent=y->parent;
             
            if(y->parent==nil){
                                root=x;
                                }
            else{
                if(y==(y->parent)->left){(y->parent)->left=x;} 
                 else{(y->parent)->right=x;}
                 }
              
            if(y!=p){p->data=y->data;}  
     }//treap delete
     
     node* get_root(){return root;}
     
     
       void Preorder_walk(node *p){
           if(p!=nil){ 
                       cout&lt&lt" "&lt&ltp->data&lt&lt" ";
                       Preorder_walk(p->left);
                       Preorder_walk(p->right);
                       }
           }//preorder walk finish
     
     
      };
      
      
int main(){
    
    Treap at;
    int myint;
    do{
        cin>>myint;
        at.Treap_Insert(myint);
         at.Preorder_walk(at.get_root());cout&lt&ltendl&lt&lt"\n";
        }
        while(myint!=42);
    
    
    cout&lt&ltendl;system("pause");
    return 0;
    }
</p>
	<br><br>
<a href="treap.cpp" download><button type="button">Download</button></a>	
                           
						</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
<div class="portfolio-modal modal fade" id="portfolioModal2" tabindex="-1" role="dialog" aria-hidden="true" >
        <div class="modal-content">
            <div class="close-modal" data-dismiss="modal">
                <div class="lr">
                    <div class="rl">
                    </div>
                </div>
            </div>
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-lg-offset-2">
                        <div class="modal-body">
                            <!-- Project Details Go Here -->
                             
                            <p class="item-intro text-muted">  <pre class='brush: cpp'>#include&ltiostream&gt
#include&ltvector&gt
#include&ltstring&gt
#define null NULL
#define black true
#define red false

using namespace std;

struct node{
       
       int data;
       bool color;
       node *left;
       node *right;
       node *parent;
             
       };

class Red_Black_Tree{
      
      node *root,*nil;
      public:
             Red_Black_Tree(){nil=new node;nil->data=null;nil->left=null;nil->right=null;nil->parent=null;root=nil;}
        
      void Left_Rotate(node *p){
           
      node *y=p->right;
      y->parent=p->parent;
           
           if(p->parent!=nil){if(p==(p->parent->left)){y->parent->left=y;}else{y->parent->right=y;}}
           else{root=y;}
        p->right=y->left;
        if(p->right!=nil) p->right->parent=p;
        y->left=p;
        p->parent=y;   
           }//left rotate close  
        
      void Right_Rotate(node *p){
           //cout&lt&lt" p right "&lt&ltp&lt&ltendl;
      node *y=p->left;
      y->parent=p->parent;
           
           if(p->parent!=nil){if(p==(p->parent->left)){y->parent->left=y;}else{y->parent->right=y;}}
           else{root=y;}
        p->left=y->right;
        if(p->left!=nil)p->left->parent=p;
        y->right=p;
        p->parent=y;   
           }//right rotate close  
        
        
      void Red_Black_Insert(int a){
           
           node *x=root,*y=nil;
           while(x!=nil){
                          y=x;
                          if(x->data>a){x=x->left;}
                          else{x=x->right;}
                          }
           node *temp=new node;
           temp->data=a;
           temp->left=nil;
           temp->right=nil;
           temp->parent=y;
           temp->color=red;
           if(temp->parent==nil){root=temp;}
           else{
                if(a&lty->data){ y->left=temp; }else{y->right=temp;}}
     Redify(temp);
           }//red black insert close
     
      void Redify(node *p){
           
           node *z=p;
           while(z!=nil && z->parent!=nil&& z->parent->parent!=nil && z->parent->color==red){
                    
                    if(z->parent->parent->left==z->parent){ //cout&lt&lt"\nparent left\n";
                                                           if(z->parent->parent->right!=nil && z->parent->parent->right->color==red){
                                                                                //case 1                    
                                                                                 z->parent->color=black;
                                                                                 z->parent->parent->right->color=black;
                                                                                 z=z->parent->parent;                   
                                                                                 z->color=red;                   
                                                                                //cout&lt&lt"\nparent right red\n";       
                                                                                             }//case 1 finishh
                                                           else{
                                                                                //case 2
                                                                                if(z==z->parent->right){Left_Rotate((z=z->parent));
                                                                                //cout&lt&lt"\nself right\n";
                                                                                }
                                                                                //case 3
                                                                                //cout&lt&lt"\nself left\n";
                                                                                 z->parent->color=black;
                                                                                 z->parent->parent->color=red;
                                                                                 Right_Rotate(z->parent->parent);
                                                                
                                                                }//case 2 and 3 ends
                                                             }  // first left if finish  
                         
                        else{
                             
                             if(z->parent->parent->left!=nil && z->parent->parent->left->color==red){
                                                                                //case 1                    
                                                                                 z->parent->color=black;
                                                                                 z->parent->parent->left->color=black;
                                                                                 z=z->parent->parent;                   
                                                                                 z->color=red;                   
                                                                                                    }//case 1 finishh
                                                           else{
                                                                                //case 2
                                                                                if(z==z->parent->left){Right_Rotate((z=z->parent));}
                                                                                //case 3
                                                                                 z->parent->color=black;
                                                                                 z->parent->parent->color=red;
                                                                                 Left_Rotate(z->parent->parent);
                                                                
                                                                }//case 2 and 3 ends
                             
                             }//else close 
                         
                         }//while close
           root->color=black;
           }     // Redify finish
           
       node* get_root(){return root;}
       
       node* Red_Black_Minimum(node *p){if(p->left!=nil){return Red_Black_Minimum(p->left);}else{ return p;}}//red black minimun clccose
    
    
     node* Red_Black_Succesor(node* p){
           
           if(p->right!=nil){return Red_Black_Minimum(p->right);}
           node *y=p;
           while(y!=nil && y==(y->parent)->right){ y=y->parent;  }
           return (y==nil?nil:y->parent);
           }//red black succesor cllose
      
       
       
       void Red_Black_Delete(node* p){
            
            node* x=nil,*y=nil;
            if(p->left==nil ||p->right==nil){y=p;}else{y=Red_Black_Succesor(p);}
            if(y->left!=nil){x=y->left;}else{x=y->right;}
            x->parent=y->parent;
            
            if(y->parent==nil){root=x;}
            else{if(y==y->parent->left){x->parent->left=x;}else{x->parent->right=x;}}
            if(y!=p){p->data=y->data;}
            if(y->color==black){Delete_Redify(x);}
            }//red black delete finish
    
      void Delete_Redify(node* p){
           
           node* w=nil;
           
           while(p!=root && p->color==black){
                         
                         if(p->parent->left==p){
                                                w=p->parent->right;
                                                //case 1
                                                if( w->color==red ){w->color=black;w->parent->color=red;Left_Rotate(w->parent);
                                                w=p->parent->right;}
                                                //case 1 ends
                                                else{
                                                     //case 2
                                                     if(w->left->color==black && w->right->color==black){
                                                                              
                                                                              w->color=red;
                                                                              p=p->parent; 
                                                                              }//case 2 ends
                                                     
                                                     else {//case 3
                                                          if(w->left->color==red && w->right->color==black){w->color=red;
                                                          w->left->color=black;Right_Rotate(w);w=p->parent->right;}
                                                          //case 4
                                                     w->color=p->parent->color;p->parent->color=black;w->right->color=black;Left_Rotate(w->parent);p=root;
                                                     }//case 3 4 ensd
                                                     }//else finish
                                                
                                                
                                                }//if finish
                         else{
                              w=p->parent->left;
                              //case 1
                              if(w->color==red){w->parent->color=red;w->color=black;Right_Rotate(p->parent);w=p->parent->left;}
                              //case 1 ends
                              else{//case 2
                                   if(w->left->color==black && w->right->color==black){
                                           w->color=red;p=p->parent;                 
                                                            
                                                            }//case 2 ends
                                   else{
                                        //case 3
                                        if(w->right->color==red && w->left->color==black){w->color=red;w->right->color=black;
                                        Left_Rotate(w);
                                        w=p->parent->left;}
                                        //case 4
                                        w->color=w->parent->color;w->parent->color=black;w->left->color=black;Right_Rotate(w->parent);p=root;
                                        //case 3 and 4 ends
                                        }
                                   
                                   }
                              
                              } 
                         
                         
                         }//while fingish
           
           p->color=black;
           
           } //delete redify finish       
      
       void Inorder_walk(node *p){
           if(p!=nil){ 
                       Inorder_walk(p->left);
                       cout&lt&lt" "&lt&ltp->data&lt&lt" ";
                       Inorder_walk(p->right);
                       }
           }//inorder walk finish
     
     void Preorder_walk(node *p){
           if(p!=nil){ 
                       cout&lt&lt" "&lt&ltp->data&lt&lt" ";
                       Preorder_walk(p->left);
                       Preorder_walk(p->right);
                       }
           }//preorder walk finish
     
      
      
      
      };

int main(){
   
    Red_Black_Tree rbt;
    
     int myint;
    do{
        cin>>myint;
        rbt.Red_Black_Insert(myint);
         rbt.Preorder_walk(rbt.get_root());cout&lt&ltendl&lt&lt"\n";
        }
        while(myint!=42);
    
    rbt.Inorder_walk(rbt.get_root());cout&lt&ltendl&lt&lt"k1\n";
    rbt.Red_Black_Delete(rbt.get_root());
     rbt.Preorder_walk(rbt.get_root());cout&lt&ltendl&lt&lt"k2\n";
    rbt.Red_Black_Delete(rbt.get_root());
     rbt.Preorder_walk(rbt.get_root());cout&lt&ltendl&lt&lt"3\n";
    rbt.Red_Black_Delete(rbt.get_root());
         rbt.Preorder_walk(rbt.get_root());cout&lt&ltendl&lt&lt"\n";
    cout&lt&ltendl;system("pause");
    return 0;
    }

</p>
          <br><br>
 <a href="red_black.cpp" download><button type="button">Download</button></a>						</div>
                    </div>
                </div>
            </div>
        </div>
    </div><div class="portfolio-modal modal fade" id="portfolioModal3" tabindex="-1" role="dialog" aria-hidden="true" >
        <div class="modal-content">
            <div class="close-modal" data-dismiss="modal">
                <div class="lr">
                    <div class="rl">
                    </div>
                </div>
            </div>
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-lg-offset-2">
                        <div class="modal-body">
                            <!-- Project Details Go Here -->
                             
                            <p class="item-intro text-muted">  <pre class='brush: cpp'>#include&ltiostream&gt
#include&ltvector&gt
#include&ltstring&gt
#include&ltstack&gt
#define null NULL
#define black true
#define red false

using namespace std;

struct node{
       
       int data;
       bool color;
       node *left;
       node *right;
                   
       };

class Red_Black_Tree{
      
      node *root,*root1,*nil;stack&ltnode *> stc;
      public:
             Red_Black_Tree(){nil=new node;nil->data=null;nil->left=null;nil->right=null;root=new node;root=nil;}
        
      void Left_Rotate(node *p,node* parent){
           
      node *y=p->right;
      //y->parent=p->parent;
           
          if(parent!=nil){if(p==(parent->left)){parent->left=y;}else{parent->right=y;}}
           else{root=y;}
        p->right=y->left ;
      //  if(p->right!=nil) p->right->parent=p;
        y->left=p;
        //p->parent=y;   
           }//left rotate close  
        
      void Right_Rotate(node *p,node* parent){
           //cout&lt&lt" p right "&lt&ltp&lt&ltendl;
      node *y=p->left;
     // y->parent=p->parent;
           
           if(parent!=nil){if(p==(parent->left)){parent->left=y;}else{parent->right=y;}}
           else{root=y;}
        p->left=y->right;
        //if(p->left!=nil)p->left->parent=p;
        y->right=p;
        //p->parent=y;   
           }//right rotate close  
        
        
      void Red_Black_Insert(int a){
           while(!stc.empty())stc.pop();
           stc.push(nil);
           node *x=root,*y=nil;
           while(x!=nil){
                          y=x;
                          stc.push(y);
                          if(x->data>a){x=x->left;}
                          else{x=x->right;}
                          }
           node *temp=new node;
           temp->data=a;
           temp->left=nil;
           temp->right=nil;
           //temp->parent=y;
           temp->color=red;
           
           if(stc.top()==nil){root=temp;}
           else{
                if(a&lty-&gtdata){ y->left=temp; }else{y->right=temp;}}
     Redify(temp);
           }//red black insert close
     
      void Redify(node *p){
           node *parent=nil,*parent_parent=nil;
           node *z=p;
          parent=stc.top();stc.pop();
           while(parent->color==red){
                    parent_parent=stc.top();stc.pop();
                    if(parent_parent->left==parent){ //cout&lt&lt"\nparent left\n";
                                                           if( parent_parent->right->color==red){
                                                                                //case 1                    
                                                                                 parent->color=black;
                                                                                 parent_parent->right->color=black;
                                                                                 z=parent_parent;                   
                                                                                 z->color=red;
                                                                                 parent=stc.top();stc.pop();                  
                                                                                //cout&lt&lt"\nparent right red\n";       
                                                                                             }//case 1 finishh
                                                           else{
                                                                                //case 2
                                                                                if(z==parent->right){node *temp=z;
                                                                                                     z=parent;
                                                                                                     parent=parent_parent;
                                                                                                     Left_Rotate((z),parent);
                                                                                                     parent=temp;
                                                                                //cout&lt&lt"\nself right\n";
                                                                                }
                                                                                //case 3
                                                                                //cout&lt&lt"\nself left\n";
                                                                                 parent->color=black;
                                                                                 parent_parent->color=red;
                                                                                 node* temp=stc.top();stc.pop();
                                                                                 Right_Rotate(parent_parent,temp);
                                                                
                                                                }//case 2 and 3 ends
                                                             }  // first left if finish  
                         
                        else{
                             
                             if(parent_parent->left->color==red){
                                                                                //case 1                    
                                                                                 parent->color=black;
                                                                                 parent_parent->left->color=black;
                                                                                 z=parent_parent;                   
                                                                                 z->color=red;                   
                                                                                   parent=stc.top();stc.pop();                }//case 1 finishh
                                                           else{
                                                                                //case 2
                                                                                if(z==parent->left){node* temp=z;
                                                                                                    z=parent;
                                                                                                     parent=parent_parent;Right_Rotate(z,parent);
                                                                                                     parent=temp;
                                                                                                     }
                                                                                //case 3
                                                                                 parent->color=black;
                                                                                 parent_parent->color=red;
                                                                                 node* temp=stc.top();stc.pop();
                                                                                 Left_Rotate(parent_parent,temp);
                                                                
                                                                }//case 2 and 3 ends
                             
                             }//else close 
                         
                         }//while close
           root->color=black;
           }     // Redify finish
           
       node* get_root(){return root;}
       
       node* Red_Black_Minimum(node *p){if(p->left!=nil){stc.push(p);return Red_Black_Minimum(p->left);}else{ return p;}}//red black minimun clccose
    
    
     node* Red_Black_Succesor(node* p){
           
           if(p->right!=nil){return Red_Black_Minimum(p->right);}
           node *y=p;
//           while(y!=nil && y==(y->parent)->right){ y=y->parent;  }
  //         return (y->parent);
           }//red black succesor cllose
      
       void Red_Black_Search(node* q,node* p){
            if(q==p){return ;}
            stc.push(q);
            return Red_Black_Search(q->data>p->data?q->left:q->right,p);
            }
       
       void Red_Black_Delete(node* p){
            while(!stc.empty())stc.pop();
           stc.push(nil);
           Red_Black_Search(root,p);
            node* x=nil,*y=nil;
            if(p->left==nil ||p->right==nil){y=p;}else{
                            stc.push(p);
                            y=Red_Black_Minimum(p->right);}
            if(y->left!=nil){x=y->left;}else{x=y->right;}
           // x->parent=y->parent;
            cout&lt&lt" x data "&lt&ltx->data&lt&lt"\n";
            node* parent=stc.top();
            if(parent==nil){root=x;}
            else{if(y==parent->left){parent->left=x;}else{parent->right=x;}}
            if(y!=p){p->data=y->data;}
            if(y->color==black){Delete_Redify(x);}
            }//red black delete finish
    
      void Delete_Redify(node* p){
           
            node* w=nil;node* parent_parent=nil;
            node* parent=stc.top();stc.pop();
            while(p!=root && p->color==black){
                         parent_parent=stc.top();
                         if(parent->left==p){
                                                w=parent->right;
                                                //case 1
                                                if( w->color==red ){w->color=black;parent->color=red;
                                                Left_Rotate(parent,parent_parent);
                                                parent_parent=w;
                                                stc.push(w);
                                                w=parent->right;}
                                                //case 1 ends
                                                else{
                                                     //case 2
                                                     if(w->left->color==black && w->right->color==black){
                                                                              
                                                                              w->color=red;
                                                                              p=parent; 
                                                                              parent=parent_parent;
                                                                              stc.pop();
                                                                              }//case 2 ends
                                                     
                                                     else {//case 3
                                                          if(w->left->color==red && w->right->color==black){
                                                                                 w->color=red;w->left->color=black;Right_Rotate(w,parent);
                                                                                 w=parent->right;}
                                                          //case 4
                                                     w->color=parent->color;parent->color=black;w->right->color=black;
                                                     Left_Rotate(parent,parent_parent);p=root;
                                                     }//case 3 4 ensd
                                                     }//else finish
                                                
                                                
                                                }//if finish
                         else{
                              w=parent->left;
                              //case 1
                              if(w->color==red){parent->color=red;w->color=black;
                              Right_Rotate(parent,parent_parent);
                                                parent_parent=w;
                                                stc.push(w);
                              w=parent->left;}
                              //case 1 ends
                              else{//case 2
                                   if(w->left->color==black && w->right->color==black){
                                           w->color=red;
                                           p=parent; 
                                                                              parent=parent_parent;
                                                                              stc.pop();                 
                                                            }//case 2 ends
                                   else{
                                        //case 3
                                        if(w->right->color==red && w->left->color==black){w->color=red;
                                        w->right->color=black;
                                        Left_Rotate(w,parent);
                                        w=parent->left;}
                                        //case 4
                                        w->color=parent->color;parent->color=black;w->left->color=black;
                                        Left_Rotate(parent,parent_parent);p=root;
                                        //case 3 and 4 ends
                                        }
                                   
                                   }
                              
                              } 
                         
                         
                         }//while fingish
           
           p->color=black;
           
           } //delete redify finish       
//     */ 
       void Inorder_walk(node *p){
           if(p!=nil){ 
                       Inorder_walk(p->left);
                       cout&lt&lt" "&lt&ltp->data&lt&lt" ";
                       Inorder_walk(p->right);
                       }
           }//inorder walk finish
     
     void Preorder_walk(node *p){
           if(p!=nil){ 
                       cout&lt&lt" "&lt&ltp->data&lt&lt" ";
                       Preorder_walk(p->left);
                       Preorder_walk(p->right);
                       }
           }//preorder walk finish
     
      
      
      
      };

int main(){
   
    Red_Black_Tree rbt;
    
     int myint;
    do{
        cin>>myint;
        rbt.Red_Black_Insert(myint);
         rbt.Preorder_walk(rbt.get_root());cout&lt&ltendl&lt&lt"\n";
        }
        while(myint!=42);
    
  //  rbt.Inorder_walk(rbt.get_root());cout&lt&ltendl&lt&lt"\n";
    rbt.Red_Black_Delete(rbt.get_root());
    cout&lt&lt"\nk 1\n";
         rbt.Preorder_walk(rbt.get_root());cout&lt&ltendl&lt&lt"\n";
    rbt.Red_Black_Delete(rbt.get_root());
    cout&lt&lt"\nk 2\n";
         rbt.Preorder_walk(rbt.get_root());cout&lt&ltendl&lt&lt"\n";
    rbt.Red_Black_Delete(rbt.get_root());
    cout&lt&lt"\nk 3\n";
         rbt.Preorder_walk(rbt.get_root());cout&lt&ltendl&lt&lt"\n";
    cout&lt&ltendl;system("pause");
    return 0;
    }
</p>
            <br><br>
<a href="red_black_without_parent.cpp" download><button type="button">Download</button></a>	               
						</div>
                    </div>
                </div>
            </div>
        </div>
    </div><div class="portfolio-modal modal fade" id="portfolioModal4" tabindex="-1" role="dialog" aria-hidden="true" >
        <div class="modal-content">
            <div class="close-modal" data-dismiss="modal">
                <div class="lr">
                    <div class="rl">
                    </div>
                </div>
            </div>
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-lg-offset-2">
                        <div class="modal-body">
                            <!-- Project Details Go Here -->
                             
                            <p class="item-intro text-muted">  <pre class='brush: cpp'>#include&ltiostream&gt
#include&ltvector&gt
#include&ltcmath&gt
#include&ltalgorithm&gt
#define null NULL
using namespace std;

struct node{
       int data;
       int height;
       node* left;
       node* right;
       node* parent;
       };


class AVL_Tree{
      node* root,*nil;
      public:
      AVL_Tree(){nil=new node;nil->data=null;nil->left=null;nil->right=null;nil->parent=nil;nil->height=0;root=nil;}
            
         node* make_node(int a){
               node* temp=new node;
               temp->data=a;
               temp->height=1;
               temp->left=nil;
               temp->right=nil;
               temp->parent=nil;
              return temp; 
               }
         
         void Left_Rotate(node *p){
           
      node *y=p->right;
      y->parent=p->parent;
           
           if(p->parent!=nil){if(p==(p->parent->left)){y->parent->left=y;}else{y->parent->right=y;}}
           else{root=y;}
        p->right=y->left;
        if(p->right!=nil) p->right->parent=p;
        y->left=p;
        p->parent=y;   
        p->height=max(p->left->height,p->right->height)+1;
        y->height=max(y->left->height,y->right->height)+1;
           
           }//left rotate close  
        
      void Right_Rotate(node *p){
           //cout&lt&lt" p right "&lt&ltp&lt&ltendl;
      node *y=p->left;
      y->parent=p->parent;
           
           if(p->parent!=nil){if(p==(p->parent->left)){y->parent->left=y;}else{y->parent->right=y;}}
           else{root=y;}
        p->left=y->right;
        if(p->left!=nil)p->left->parent=p;
        y->right=p;
        p->parent=y;   
        
        p->height=max(p->left->height,p->right->height)+1;
        y->height=max(y->left->height,y->right->height)+1;
           }//right rotate close  
        
        
          void AVL_Tree_Insert(int a){ root=AVL_Tree_Inser(root,a);}
            
         node* AVL_Tree_Inser(node* p,int a){
              if(p==nil){
			  	p=make_node(a);
                return p;
                         }
              if(a<p->data){
                          p->left=AVL_Tree_Inser(p->left,a);
                          p->left->parent=p;
                          p->height=p->left->height+1;
                            }
              else{
                   p->right=AVL_Tree_Inser(p->right,a);
                          p->right->parent=p;
                          p->height=p->right->height+1;
                  }  
              p=AVL_Tree_Balance(p);                  
              return p;      
              }//avl insert finish
            
           node* AVL_Tree_Balance(node* p){
                
                if(1>=(int)fabs(p->left->height-p->right->height)){cout&lt&lt"yes";return p;}
                if(p->left->height>p->right->height){node* y=p->left;
                                                     if(y->right->height>y->left->height){
                                                                                       Left_Rotate(y);   
                                                                                          }
                                                     Right_Rotate(p);
                                                     p=p->parent;
                                                     }
                else{
                     node* y=p->right;
                                                     if(y->left->height>y->right->height){
                                                                                       Right_Rotate(y);   
                                                                                          }
                                                     Left_Rotate(p);
                                                     p=p->parent;
                     
                     
                     }
                     
                  return p;   
                } // avl balance finish
      
       void Preorder_walk(node *p){
           if(p!=nil){ 
                       cout&lt&lt" "&lt&ltp->data&lt&lt" ";
                       Preorder_walk(p->left);
                       Preorder_walk(p->right);
                       }
           }//preorder walk finish
     
     node* get_root(){return root;}
      
      };




int main(){
    AVL_Tree at;
    int myint;
    do{
        cin>>myint;
        at.AVL_Tree_Insert(myint);
         at.Preorder_walk(at.get_root());cout&lt&ltendl&lt&lt"\n";
        }
        while(myint!=10);
    
    cout&lt&ltendl;system("pause");
    return 0;
    }
</p>
             <br><br>
<a href="avl.cpp" download><button type="button">Download</button></a>	              
						</div>
                    </div>
                </div>
            </div>
        </div>
    </div><div class="portfolio-modal modal fade" id="portfolioModal5" tabindex="-1" role="dialog" aria-hidden="true" >
        <div class="modal-content">
            <div class="close-modal" data-dismiss="modal">
                <div class="lr">
                    <div class="rl">
                    </div>
                </div>
            </div>
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-lg-offset-2">
                        <div class="modal-body">
                            <!-- Project Details Go Here -->
                             
                            <p class="item-intro text-muted">  <pre class='brush: cpp'>
     #include&ltiostream&gt
#include&ltvector&gt
#include&ltstring&gt
#include&ltstack&gt
#define null NULL
#define black true
#define red false

using namespace std;

struct node{
       
       int data;
       bool color;
       node *left;
       node *right;
                   
       };

class Red_Black_Tree{
      
      node *root,*nil;stack&ltnode *> stc;vector&ltnode *> roots;
      public:
             Red_Black_Tree(){ nil=new node;nil->data=null;nil->left=null;nil->right=null;root=new node;root=nil; }
        
      void Left_Rotate(node *p,node* parent){
           
      node *y=p->right;
      //y->parent=p->parent;
           
          if(parent!=nil){if(p==(parent->left)){parent->left=y;}else{parent->right=y;}}
           else{root=y;}
        p->right=y->left ;
      //  if(p->right!=nil) p->right->parent=p;
        y->left=p;
        //p->parent=y;   
           }//left rotate close  
        
      void Right_Rotate(node *p,node* parent){
           //cout&lt&lt" p right "&lt&ltp&lt&ltendl;
      node *y=p->left;
     // y->parent=p->parent;
           
           if(parent!=nil){if(p==(parent->left)){parent->left=y;}else{parent->right=y;}}
           else{root=y;}
        p->left=y->right;
        //if(p->left!=nil)p->left->parent=p;
        y->right=p;
        //p->parent=y;   
           }//right rotate close  
        
        
        node * Copy_Node(node * p){
             node *temp=new node;
             temp->data=p->data;
             temp->left=p->left;
             temp->right=p->right;
             temp->color=p->color;
             return temp;
             }
        
       node* Make_Node(int k){
             node* temp=new node;
             temp->data=k;
             temp->left=nil;
             temp->right=nil;
             temp->color=red;
             return temp;
             }
           
      void Persistent_Insert(int a){
           while(!stc.empty())stc.pop();
           stc.push(nil);
           node* temp=Persistent_Tree_Insert(root,a);
           temp->color=black;
           roots.push_back(temp);
           
           }
               
      node* Persistent_Tree_Insert(node* p,int a){
           node* x=nil;
           if(p==nil){
                       x=Make_Node(a);
                       Redify(x);
                      }
           else{
                
                      x=Copy_Node(p);
                      stc.push(x);
                      if(a<x->data){x->left=Persistent_Tree_Insert(x->left,a);}
                      else{x->right=Persistent_Tree_Insert(x->right,a);}
                }
           return x;
            }    
     
           
      void Red_Black_Insert(int a){
           
           
           while(!stc.empty())stc.pop();
           stc.push(nil);
           node *x=root,*y=nil;
           
           while(x!=nil){
                          y=x;
                          stc.push(y);
                          if(x->data>a){x=x->left;}
                          else{x=x->right;}
                          }
           
           node *temp=new node;
           temp->data=a;
           temp->left=nil;
           temp->right=nil;
           //temp->parent=y;
           temp->color=red;
           
           if(stc.top()==nil){root=temp;}
           else{
                if(a&lty-&gtdata){ y->left=temp; }else{y->right=temp;}}
             Redify(temp);
           }//red black insert close
     
     
       void Redify(node *p){
           node *parent=nil,*parent_parent=nil;
           node *z=p;
           parent=stc.top();
           stc.pop();
           while(parent->color==red){
                    parent_parent=stc.top();stc.pop();
                    if(parent_parent->left==parent){ //cout&lt&lt"\nparent left\n";
                                                           if( parent_parent->right->color==red){
                                                                                //case 1                    
                                                                                 parent->color=black;
                                                                                 parent_parent->right->color=black;
                                                                                 z=parent_parent;                   
                                                                                 z->color=red;
                                                                                 parent=stc.top();stc.pop();                  
                                                                                //cout&lt&lt"\nparent right red\n";       
                                                                                             }//case 1 finishh
                                                           else{
                                                                                //case 2
                                                                                if(z==parent->right){node *temp=z;
                                                                                                     z=parent;
                                                                                                     parent=parent_parent;
                                                                                                     Left_Rotate((z),parent);
                                                                                                     parent=temp;
                                                                                //cout&lt&lt"\nself right\n";
                                                                                }
                                                                                //case 3
                                                                                //cout&lt&lt"\nself left\n";
                                                                                 parent->color=black;
                                                                                 parent_parent->color=red;
                                                                                 node* temp=stc.top();stc.pop();
                                                                                 Right_Rotate(parent_parent,temp);
                                                                
                                                                }//case 2 and 3 ends
                                                             }  // first left if finish  
                         
                        else{
                             
                             if(parent_parent->left->color==red){
                                                                                //case 1                    
                                                                                 parent->color=black;
                                                                                 parent_parent->left->color=black;
                                                                                 z=parent_parent;                   
                                                                                 z->color=red;                   
                                                                                   parent=stc.top();stc.pop();                }//case 1 finishh
                                                           else{
                                                                                //case 2
                                                                                if(z==parent->left){node* temp=z;
                                                                                                    z=parent;
                                                                                                     parent=parent_parent;Right_Rotate(z,parent);
                                                                                                     parent=temp;
                                                                                                     }
                                                                                //case 3
                                                                                 parent->color=black;
                                                                                 parent_parent->color=red;
                                                                                 node* temp=stc.top();stc.pop();
                                                                                 Left_Rotate(parent_parent,temp);
                                                                
                                                                }//case 2 and 3 ends
                             
                             }//else close 
                         
                         }//while close
           root->color=black;
           }     // Redify finish
           
       node* get_root(){return root;}
       
       node* Red_Black_Minimum(node *p){if(p->left!=nil){stc.push(p);
       return Red_Black_Minimum(p->left);}else{ return p;}}//red black minimun clccose
    
    
       node* Red_Black_Succesor(node* p){
           
           if(p->right!=nil){return Red_Black_Minimum(p->right);}
           node *y=p;
//           while(y!=nil && y==(y->parent)->right){ y=y->parent;  }
  //         return (y->parent);
           }//red black succesor cllose
      
       
         
          void Persistent_Tree_Search(node* q,node* p){
            if(q->data==p->data){
                                 return ;}
            stc.push(q);
            if(p->data<q->data){
             q->left=Copy_Node(q->left);                                
            return Persistent_Tree_Search(q->left,p);
            }
            else{
                 
             q->right=Copy_Node(q->right); 
            return Persistent_Tree_Search(q->right,p);
                 }
            }//persistent search ends
       
    
       node* Persistent_Tree_Minimum(node *p){
       if(p->left!=nil){stc.push(p);
       p->left=Copy_Node(p->left);
       return Persistent_Tree_Minimum(p->left);}else{ return p;}}//persistent minimun clccose
       
       
       void Persistent_Tree_Delete(node* p){
          
            while(!stc.empty())stc.pop();
            stc.push(nil);
            node* root1=Copy_Node(root);
            Persistent_Tree_Search(root1,p);
            node* x=nil,*y=nil;
            
            if(root1->data==p->data){stc.push(root1);}
            p=stc.top();
            //cout&lt&lt"stctop "&lt&ltp->data&lt&lt" left"&lt&ltp->left->data&lt&lt" rixg"&lt&ltp->right->data;
            //cout&lt&lt"pp"&lt&ltp->data;
                        if(p->left==nil ||p->right==nil){stc.pop();y=p;}else{
                                          //  cout&lt&lt"pright "&lt&ltp->right->data;
                                            p->right=Copy_Node(p->right);
                                            
                                         y=Persistent_Tree_Minimum(p->right);}
            if(y->left!=nil){x=y->left;}else{x=y->right;}
           // x->parent=y->parent;
            //cout&lt&lt" x data "&lt&ltx->data&lt&lt"\n";
            node* parent=stc.top();
            if(parent==nil){root1=x;}
            else{if(y==parent->left){parent->left=x;}else{parent->right=x;}}
            if(y!=p){p->data=y->data;}
            if(y->color==black){Delete_Redify(x,root1);}
           
            roots.push_back(root1);
            }//persistent tree delete finish
    
       
       void Red_Black_Search(node* q,node* p){
            if(q==p){
                    // stc.push(q);
                     return ;}
            stc.push(q);
            return Red_Black_Search(q->data>p->data?q->left:q->right,p);
            }
       
       void Red_Black_Delete(node* p){
            while(!stc.empty())stc.pop();
           stc.push(nil);
           Red_Black_Search(root,p);
            node* x=nil,*y=nil;
            if(p->left==nil ||p->right==nil){y=p;}else{
                            stc.push(p);
                            y=Red_Black_Minimum(p->right);}
            if(y->left!=nil){x=y->left;}else{x=y->right;}
           // x->parent=y->parent;
           // cout&lt&lt" x data "&lt&ltx->data&lt&lt"\n";
            node* parent=stc.top();
            if(parent==nil){root=x;}
            else{if(y==parent->left){parent->left=x;}else{parent->right=x;}}
            if(y!=p){p->data=y->data;}
            if(y->color==black){Delete_Redify(x,root);}
            }//red black delete finish
    
    
    
       void Delete_Redify(node* p,node* rot){
           
            node* w=nil;node* parent_parent=nil;
            node* parent=stc.top();stc.pop();
            while(p!=rot && p->color==black){
                         parent_parent=stc.top();
                         if(parent->left==p){
                                                w=parent->right;
                                                //case 1
                                                if( w->color==red ){w->color=black;parent->color=red;
                                                Left_Rotate(parent,parent_parent);
                                                parent_parent=w;
                                                stc.push(w);
                                                w=parent->right;}
                                                //case 1 ends
                                                else{
                                                     //case 2
                                                     if(w->left->color==black && w->right->color==black){
                                                                              
                                                                              w->color=red;
                                                                              p=parent; 
                                                                              parent=parent_parent;
                                                                              stc.pop();
                                                                              }//case 2 ends
                                                     
                                                     else {//case 3
                                                          if(w->left->color==red && w->right->color==black){
                                                                                 w->color=red;w->left->color=black;Right_Rotate(w,parent);
                                                                                 w=parent->right;}
                                                          //case 4
                                                     w->color=parent->color;parent->color=black;w->right->color=black;
                                                     Left_Rotate(parent,parent_parent);p=rot;
                                                     }//case 3 4 ensd
                                                     }//else finish
                                                
                                                
                                                }//if finish
                         else{
                              w=parent->left;
                              //case 1
                              if(w->color==red){parent->color=red;w->color=black;
                              Right_Rotate(parent,parent_parent);
                                                parent_parent=w;
                                                stc.push(w);
                              w=parent->left;}
                              //case 1 ends
                              else{//case 2
                                   if(w->left->color==black && w->right->color==black){
                                           w->color=red;
                                           p=parent; 
                                                                              parent=parent_parent;
                                                                              stc.pop();                 
                                                            }//case 2 ends
                                   else{
                                        //case 3
                                        if(w->right->color==red && w->left->color==black){w->color=red;
                                        w->right->color=black;
                                        Left_Rotate(w,parent);
                                        w=parent->left;}
                                        //case 4
                                        w->color=parent->color;parent->color=black;w->left->color=black;
                                        Left_Rotate(parent,parent_parent);p=rot;
                                        //case 3 and 4 ends
                                        }
                                   
                                   }
                              
                              } 
                         
                         
                         }//while fingish
           
           p->color=black;
           
           } //delete redify finish       
//     */ 
       void Inorder_walk(node *p){
           if(p!=nil){ 
                       Inorder_walk(p->left);
                       cout&lt&lt" "&lt&ltp->data&lt&lt" ";
                       Inorder_walk(p->right);
                       }
           }//inorder walk finish
     
     void Preorder_walk(node *p){
           if(p!=nil){ 
                       cout&lt&lt" "&lt&ltp->data&lt&lt" ";
                       Preorder_walk(p->left);
                       Preorder_walk(p->right);
                       }
           }//preorder walk finish
     
     vector&ltnode *> get_roots(){return roots;} 
      
      
      };

int main(){
   
    Red_Black_Tree rbt;
    
     int myint;
    do{
        cin>>myint;
        rbt.Red_Black_Insert(myint);
         rbt.Preorder_walk(rbt.get_root());cout&lt&ltendl&lt&lt"\n";
        }
        while(myint!=42);
    
  //  rbt.Inorder_walk(rbt.get_root());cout&lt&ltendl&lt&lt"\n";
    rbt.Red_Black_Delete(rbt.get_root());
    cout&lt&lt"\nk 1\n";
         rbt.Preorder_walk(rbt.get_root());cout&lt&ltendl&lt&lt"\n";
   
    rbt.Red_Black_Delete(rbt.get_root());
    cout&lt&lt"\nk 2\n";
         rbt.Preorder_walk(rbt.get_root());cout&lt&ltendl&lt&lt"\n";
 //  rbt.Red_Black_Delete(rbt.get_root());
   // cout&lt&lt"\nk 3\n";
     //    rbt.Preorder_walk(rbt.get_root());cout&lt&ltendl&lt&lt"\n";
    rbt.Persistent_Insert(17);
    cout&lt&lt"\nok \n";
         rbt.Preorder_walk(rbt.get_roots()[0]);cout&lt&ltendl&lt&lt"\n";
  rbt.Persistent_Tree_Delete(rbt.get_root());
  cout&lt&lt"\nokk\n";
       rbt.Preorder_walk(rbt.get_roots()[rbt.get_roots().size()-1]);cout&lt&ltendl&lt&lt"\n";

    cout&lt&ltendl;system("pause");
    return 0;
    }
</p>
            <br><br>
<a href="persistent.cpp" download><button type="button">Download</button></a>	               
						</div>
                    </div>
                </div>
            </div>
        </div>
    </div><div class="portfolio-modal modal fade" id="portfolioModal6" tabindex="-1" role="dialog" aria-hidden="true" >
        <div class="modal-content">
            <div class="close-modal" data-dismiss="modal">
                <div class="lr">
                    <div class="rl">
                    </div>
                </div>
            </div>
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-lg-offset-2">
                        <div class="modal-body">
                            <!-- Project Details Go Here -->
                             
                            <p class="item-intro text-muted">  <pre class='brush: cpp'>    #include&ltiostream&gt
    #include&ltcstdio&gt
    #include&ltalloc.h&gt
    void foo( char * ptr)
    {
    ptr = (char *)malloc(255); // allocate some memory
    strcpy( ptr, "Hello World");
    }
    int main()
    {
    char *ptr = 0;
    // call function with a pointer to pointer
    foo( ptr );
    printf("%s\n", ptr);
    // free up the memory
    free(ptr);
    system("pause");
    return 0;
    }
</p>
             <br><br>
<a href="sd.cpp" download><button type="button">Download</button></a>	              
						</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <!-- jQuery Version 1.11.0 -->
    <script src="js/jquery-1.11.0.js"></script>

    <!-- Bootstrap Core JavaScript -->
    <script src="js/bootstrap.min.js"></script>

    <!-- Plugin JavaScript -->
    <script src="http://cdnjs.cloudflare.com/ajax/libs/jquery-easing/1.3/jquery.easing.min.js"></script>
    <script src="js/classie.js"></script>
    <script src="js/cbpAnimatedHeader.js"></script>

    <!-- Contact Form JavaScript -->
    <script src="js/jqBootstrapValidation.js"></script>
    <script src="js/contact_me.js"></script>

    <!-- Custom Theme JavaScript -->
    <script src="js/agency.js"></script>

</body>

</html>

<!DOCTYPE html>
<html lang="en">

<head>
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
	<script> 
	$(function(){ // I use jQuery in this example
      
           function () { close(){$(".flip").click(function(){
    $(".panel").slideUp("slow");
  });
   });
   });
$(document).ready(function(){
  $(".flip").click(function(){
    $(".panel").slideToggle("slow");
  });
});
</script>
   

    <title>Chapter-14</title>
<link rel="stylesheet" href="css/style.css" type="text/css"/>
<style>
.list {list-style-type:none}
.list > li {display:inline;
			float:left;}
</style>
    <!-- Bootstrap Core CSS -->
    <link href="css/bootstrap.min.css" rel="stylesheet">

    <link href="css/agency.css" rel="stylesheet">


   
</head>

<body id="page-top" class="index">

    <!-- Navigation -->
    
<div class="header" style="background-image:url('head.jpg'); background-repeat:no-repeat; background-position:top;margin:0 auto;

	overflow:hidden;">
	<div class="wrap">
		<div style="">
		<center><h1><font size="100px"><a href="../index.html"><img src="intro.jpg"></a></font></h1><center>
		</div>
		<div class="cname" style="font-family: Arial black, Georgia, Serif">
			
         <center><h1><font type="Arial black">Chapter-14</h1></center>
		</div>	
		<div class="clear"><center><h2><font color="#346fa1">Argumenting Data Structures</font></h2></center></div>
	</div>
</div>
   
 <div class="container" style="background-image:url('tail.jpg');background-repeat:no-repeat;background-position:top;margin:0 auto;

	overflow:hidden;margin-top:-50px">
    <section id="content" >
      <div class="inside">
        <br><br><center><h2>All Questions</h2></center>
        <div class="left" style="width:100%">
        <ul class="list"><br><br>
          <li style="margin-left:130px;width:23%"><img src="icon1.png">
            <h4><a href="#portfolioModal1" class="portfolio-link" data-toggle="modal">
                       Interval Tree
                         </a></h4>
			

			<a href="interval.cpp" style="margin-top:-50px" download>Download</a>
            <br/>
			<br>
			<br/>
			<br>
          </li>
          <li style="width:23%"><img src="icon1.png">
            <a href=""><h4><a href="#portfolioModal2" class="portfolio-link" data-toggle="modal">Min Gap </a></h4></a>
            <a href="mingap.cpp" download>Download</a>
          <br/><br/>
			<br>
			<br>
		  </li>
         
	
        </ul>
      </div>
	  
	   </div>
	  <br/>
	  <br/>
	  <br/>
	  <br/><br/>
	  <br/><br/>
	  <br/><br/>
	  <br/><br/>
	  <br/>
	 
	  
	<center><p class="lf">Copyright &copy;  <a href="http://www.httpcart.com/">httpcart.com</a> - All Rights Reserved</p>
    <p class="rf">A product of <a href="http://www.httpcart.com/">httpcart.com</a></p></center>
      </div>
    </section>
	
</div>
    
                
                  
                    
                
           
   

    <!-- Portfolio Modals -->
    <!-- Use the modals below to showcase details about your portfolio projects! -->

    <!-- Portfolio Modal 1 -->
	
    <div class="portfolio-modal modal fade" id="portfolioModal1" tabindex="-1" role="dialog" aria-hidden="true" >
        <div class="modal-content">
            <div class="close-modal" data-dismiss="modal">
                <div class="lr">
                    <div class="rl">
                    </div>
                </div>
            </div>
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-lg-offset-2">
                        <div class="modal-body">
                            <!-- Project Details Go Here -->
                             
                            <p class="item-intro text-muted">  <pre class='brush: cpp'>#include&ltiostream&gt
#include&ltvector&gt
#include&ltstring&gt
#define null NULL
#define black true
#define red false

using namespace std;

struct node{
       
       int data;//low
       int data_high;//high
       int maxs;
       bool color;
       node *left;
       node *right;
       node *parent;
             
       };

class Red_Black_Tree{
      
      node *root,*nil;
      public:
             Red_Black_Tree(){nil=new node;nil->data=null;nil->left=null;
             nil->data_high=0;nil->maxs=0;nil->right=null;nil->parent=null;root=nil;}
        
      void Left_Rotate(node *p){
           
      node *y=p->right;
      y->parent=p->parent;
           
           if(p->parent!=nil){if(p==(p->parent->left)){y->parent->left=y;}else{y->parent->right=y;}}
           else{root=y;}
        p->right=y->left;
        if(p->right!=nil) p->right->parent=p;
        y->left=p;
        p->parent=y;   
           
           p->maxs=max(max(p->left->maxs,p->right->maxs),p->data_high);
           y->maxs=max(max(y->left->maxs,y->right->maxs),y->data_high);
           }//left rotate close  
        
      void Right_Rotate(node *p){
           //cout&lt&lt" p right "&lt&ltp&lt&ltendl;
      node *y=p->left;
      y->parent=p->parent;
           
           if(p->parent!=nil){if(p==(p->parent->left)){y->parent->left=y;}else{y->parent->right=y;}}
           else{root=y;}
        p->left=y->right;
        if(p->left!=nil)p->left->parent=p;
        y->right=p;
        p->parent=y;   
           p->maxs=max(max(p->left->maxs,p->right->maxs),p->data_high);
           y->maxs=max(max(y->left->maxs,y->right->maxs),y->data_high);
           
           }//right rotate close  
        
       
       
       
        
      void Red_Black_Insert(int a,int b){
           
           node *x=root,*y=nil;
           while(x!=nil){
                          y=x;
                          if(x->data>a){x=x->left;}
                          else{x=x->right;}
                          }
           node *temp=new node;
           temp->data=a;
           temp->data_high=b;
           temp->left=nil;
           temp->right=nil;
           temp->parent=y;
           temp->maxs=b;
           temp->color=red;
           if(temp->parent==nil){root=temp;}
           else{
                if(a&lty-&gtdata){ y->left=temp; }else{y->right=temp;}}
            x=temp;
           while(x!=root && x->maxs > x->parent->maxs){x->parent->maxs=x->maxs;x=x->parent;}     
     Redify(temp);
           }//red black insert close
     
      void Redify(node *p){
           
           node *z=p;
           while(z!=nil && z->parent!=nil&& z->parent->parent!=nil && z->parent->color==red){
                    
                    if(z->parent->parent->left==z->parent){ //cout&lt&lt"\nparent left\n";
                                                           if(z->parent->parent->right!=nil && z->parent->parent->right->color==red){
                                                                                //case 1                    
                                                                                 z->parent->color=black;
                                                                                 z->parent->parent->right->color=black;
                                                                                 z=z->parent->parent;                   
                                                                                 z->color=red;                   
                                                                                //cout&lt&lt"\nparent right red\n";       
                                                                                             }//case 1 finishh
                                                           else{
                                                                                //case 2
                                                                                if(z==z->parent->right){Left_Rotate((z=z->parent));
                                                                                //cout&lt&lt"\nself right\n";
                                                                                }
                                                                                //case 3
                                                                                //cout&lt&lt"\nself left\n";
                                                                                 z->parent->color=black;
                                                                                 z->parent->parent->color=red;
                                                                                 Right_Rotate(z->parent->parent);
                                                                
                                                                }//case 2 and 3 ends
                                                             }  // first left if finish  
                         
                        else{
                             
                             if(z->parent->parent->left!=nil && z->parent->parent->left->color==red){
                                                                                //case 1                    
                                                                                 z->parent->color=black;
                                                                                 z->parent->parent->left->color=black;
                                                                                 z=z->parent->parent;                   
                                                                                 z->color=red;                   
                                                                                                    }//case 1 finishh
                                                           else{
                                                                                //case 2
                                                                                if(z==z->parent->left){Right_Rotate((z=z->parent));}
                                                                                //case 3
                                                                                 z->parent->color=black;
                                                                                 z->parent->parent->color=red;
                                                                                 Left_Rotate(z->parent->parent);
                                                                
                                                                }//case 2 and 3 ends
                             
                             }//else close 
                         
                         }//while close
           root->color=black;
           }     // Redify finish
           
       node* get_root(){return root;}
       
       node* Red_Black_Minimum(node *p){if(p->left!=nil){return Red_Black_Minimum(p->left);}else{ return p;}}//red black minimun clccose
    
    
     node* Red_Black_Succesor(node* p){
           
           if(p->right!=nil){return Red_Black_Minimum(p->right);}
           node *y=p;
           while(y!=nil && y==(y->parent)->right){ y=y->parent;  }
           return (y==nil?nil:y->parent);
           }//red black succesor cllose
      
       
       
       void Red_Black_Delete(node* p){
            
            node* x=nil,*y=nil;
            if(p->left==nil ||p->right==nil){y=p;}else{y=Red_Black_Succesor(p);}
            if(y->left!=nil){x=y->left;}else{x=y->right;}
            x->parent=y->parent;
            
            if(y->parent==nil){root=x;}
            else{if(y==y->parent->left){x->parent->left=x;}else{x->parent->right=x;}}
            if(y!=p){p->data=y->data;}
            if(y->color==black){Delete_Redify(x);}
            }//red black delete finish
    
      void Delete_Redify(node* p){
           
           node* w=nil;
           
           while(p!=root && p->color==black){
                         
                         if(p->parent->left==p){
                                                w=p->parent->right;
                                                //case 1
                                                if( w->color==red ){w->color=black;w->parent->color=red;Left_Rotate(w->parent);
                                                w=p->parent->right;}
                                                //case 1 ends
                                                else{
                                                     //case 2
                                                     if(w->left->color==black && w->right->color==black){
                                                                              
                                                                              w->color=red;
                                                                              p=p->parent; 
                                                                              }//case 2 ends
                                                     
                                                     else {//case 3
                                                          if(w->left->color==red && w->right->color==black){w->color=red;
                                                          w->left->color=black;Right_Rotate(w);w=p->parent->right;}
                                                          //case 4
                                                     w->color=p->parent->color;p->parent->color=black;w->right->color=black;Left_Rotate(w->parent);p=root;
                                                     }//case 3 4 ensd
                                                     }//else finish
                                                
                                                
                                                }//if finish
                         else{
                              w=p->parent->left;
                              //case 1
                              if(w->color==red){w->parent->color=red;w->color=black;Right_Rotate(p->parent);w=p->parent->left;}
                              //case 1 ends
                              else{//case 2
                                   if(w->left->color==black && w->right->color==black){
                                           w->color=red;p=p->parent;                 
                                                            
                                                            }//case 2 ends
                                   else{
                                        //case 3
                                        if(w->right->color==red && w->left->color==black){w->color=red;w->right->color=black;
                                        Left_Rotate(w);
                                        w=p->parent->left;}
                                        //case 4
                                        w->color=w->parent->color;w->parent->color=black;w->left->color=black;Right_Rotate(w->parent);p=root;
                                        //case 3 and 4 ends
                                        }
                                   
                                   }
                              
                              } 
                         
                         
                         }//while fingish
           
           p->color=black;
           
           } //delete redify finish       
      
      
      node* Interval_Search(node* p){
            node* x=root;
            while(x!=nil && !Overlap(p,x)){
                         if(x->left!=nil && x->left->maxs>=p->data){x=x->left;}
                         else{x=x->right;}
                         }
            return x;
            }//interval search finsih
      
      bool Overlap(node* p,node* x){
           
           if(p->data&lt=x->data_high && x->data&lt=p->data_high)return true;
           return false;
           }//overlap finish
      
       void Inorder_walk(node *p){
           if(p!=nil){ 
                       Inorder_walk(p->left);
                       cout&lt&lt" "&lt&ltp->data&lt&lt"  "&lt&ltp->data_high&lt&lt" "&lt&ltp->maxs&lt&lt"  ";
                       Inorder_walk(p->right);
                       }
           }//inorder walk finish
     
     void Preorder_walk(node *p){
           if(p!=nil){ 
                       cout&lt&lt" "&lt&ltp->data&lt&lt"  "&lt&ltp->data_high&lt&lt" "&lt&ltp->maxs&lt&lt"  ";
                       Preorder_walk(p->left);
                       Preorder_walk(p->right);
                       }
           }//preorder walk finish
     
      
      
      
      };

int main(){
   
    Red_Black_Tree rbt;
    
     int myint,myint1;
    do{
        cin>>myint>>myint1;
        rbt.Red_Black_Insert(myint,myint1);
         rbt.Preorder_walk(rbt.get_root());cout&lt&ltendl&lt&lt"\n";
        }
        while(myint!=26);
    
    int a,b;cin>>a>>b;
    
    node* temp=new node;
           temp->data=a;
           temp->data_high=b;
           temp->left=null;
           temp->right=null;
           temp->parent=null;
           temp->maxs=0;
           temp->color=red;
    temp=rbt.Interval_Search(temp);
    
                       cout&lt&lt" "&lt&lttemp->data&lt&lt"  "&lt&lttemp->data_high&lt&lt" "&lt&lttemp->maxs&lt&lt"  ";
    /*
    rbt.Inorder_walk(rbt.get_root());cout&lt&ltendl&lt&lt"k1\n";
    rbt.Red_Black_Delete(rbt.get_root());
     rbt.Preorder_walk(rbt.get_root());cout&lt&ltendl&lt&lt"k2\n";
    rbt.Red_Black_Delete(rbt.get_root());
     rbt.Preorder_walk(rbt.get_root());cout&lt&ltendl&lt&lt"3\n";
    rbt.Red_Black_Delete(rbt.get_root());
         rbt.Preorder_walk(rbt.get_root());cout&lt&ltendl&lt&lt"\n";
         */
    cout&lt&ltendl;system("pause");
    return 0;
    }
</p>
            <br><br>
<a href="interval.cpp" download><button type="button">Download</button></a>             
						</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
<div class="portfolio-modal modal fade" id="portfolioModal2" tabindex="-1" role="dialog" aria-hidden="true" >
        <div class="modal-content">
            <div class="close-modal" data-dismiss="modal">
                <div class="lr">
                    <div class="rl">
                    </div>
                </div>
            </div>
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-lg-offset-2">
                        <div class="modal-body">
                            <!-- Project Details Go Here -->
                             
                            <p class="item-intro text-muted">  <pre class='brush: cpp'>#include&ltiostream&gt
#include&ltvector&gt
#include&ltstring&gt
#define null NULL
#define black true
#define red false
#define INFINITY 999
using namespace std;

struct node{
       
       int data;
       int min;
       int max;
       int min_gap;
       bool color;
       node *left;
       node *right;
       node *parent;
             
       };

class Red_Black_Tree{
      
      node *root,*nil;
      public:
             Red_Black_Tree(){nil=new node;nil->data=null;nil->left=null;nil->right=null;nil->parent=null
             ;nil->min=INFINITY;nil->max=0;nil->min_gap=INFINITY;root=nil;}
  
      void Left_Rotate(node *p){
           
      node *y=p->right;
      y->parent=p->parent;
           
           if(p->parent!=nil){if(p==(p->parent->left)){y->parent->left=y;}else{y->parent->right=y;}}
           else{root=y;}
        p->right=y->left;
        if(p->right!=nil) p->right->parent=p;
        y->left=p;
        p->parent=y; 
        p->min=p->left==nil?p->data:p->left->min;
        p->max=p->right==nil?p->data:p->right->max;
        
        p->min_gap=min((p->left==nil?INFINITY:(min(p->left->min_gap,p->data-p->left->max))),
        (p->right==nil?INFINITY:min(p->right->min_gap,p->right->min-p->data)));
         
          y->min=y->left->min;
        y->max=y->right==nil?y->data:y->right->max;
        
        y->min_gap=min((min(y->left->min_gap,y->data-p->left->max)),(y->right==nil?INFINITY:min(y->right->min_gap,p->right->min-y->data)));
         
           }//left rotate close  
        
      void Right_Rotate(node *p){
           //cout&lt&lt" p right "&lt&ltp&lt&ltendl;
      node *y=p->left;
      y->parent=p->parent;
           
           if(p->parent!=nil){if(p==(p->parent->left)){y->parent->left=y;}else{y->parent->right=y;}}
           else{root=y;}
        p->left=y->right;
        if(p->left!=nil)p->left->parent=p;
        y->right=p;
        p->parent=y;   
        
          p->min=p->left==nil?p->data:p->left->min;
        p->max=p->right==nil?p->data:p->right->max;
        
     p->min_gap=min((p->left==nil?INFINITY:(min(p->left->min_gap,p->data-p->left->max))),
        (p->right==nil?INFINITY:min(p->right->min_gap,p->right->min-p->data)));
         
          y->min=y->left==nil?y->data:y->left->min;
        y->max=y->right->max;
        
        y->min_gap=min((y->left==nil?INFINITY:min(y->left->min_gap,y->data-p->left->max)),(min(y->right->min_gap,p->right->min-y->data)));
         
           }//right rotate close  
        
        
      void Red_Black_Insert(int a){
           
           node *x=root,*y=nil;
           while(x!=nil){
                          y=x;
                          if(x->data>a){x=x->left;}
                          else{x=x->right;}
                          }
           node *temp=new node;
           temp->data=a;
           temp->min=a;
           temp->max=a;
           temp->min_gap=INFINITY;
           temp->left=nil;
           temp->right=nil;
           temp->parent=y;
           temp->color=red;
           if(temp->parent==nil){root=temp;}
           else{
                if(a&lty-&gtdata){ y->left=temp; }else{y->right=temp;}}
                x=temp;bool a2=true;
                while(x!=root && (a2 )){
                              
                              a2=false;
                             
                             if(x==x->parent->left){
                                                    if(x->parent->min>x->min){x->parent->min=x->min;a2=true;}
                                                    if(x->parent->min_gap>x->min_gap){x->parent->min_gap=x->min_gap;a2=true;}
                                                    if(x->parent->min_gap>(x->parent->data-x->max)){x->parent->min_gap=(x->parent->data-x->max);a2=true;}
                                                    }
                                                    
                             else{
                                                    if(x->parent->max<x->max){x->parent->max=x->max;a2=true;}
                                                    if(x->parent->min_gap>x->min_gap){x->parent->min_gap=x->min_gap;a2=true;}
                                                    if(x->parent->min_gap>(x->min-x->parent->data)){x->parent->min_gap=(x->min-x->parent->data);a2=true;}
                                                    }
                             x=x->parent; }
               
                
     Redify(temp);
           }//red black insert close
     
      void Redify(node *p){
           
           node *z=p;
           while(z!=nil && z->parent!=nil&& z->parent->parent!=nil && z->parent->color==red){
                    
                    if(z->parent->parent->left==z->parent){ //cout&lt&lt"\nparent left\n";
                                                           if(z->parent->parent->right!=nil && z->parent->parent->right->color==red){
                                                                                //case 1                    
                                                                                 z->parent->color=black;
                                                                                 z->parent->parent->right->color=black;
                                                                                 z=z->parent->parent;                   
                                                                                 z->color=red;                   
                                                                                //cout&lt&lt"\nparent right red\n";       
                                                                                             }//case 1 finishh
                                                           else{
                                                                                //case 2
                                                                                if(z==z->parent->right){Left_Rotate((z=z->parent));
                                                                                //cout&lt&lt"\nself right\n";
                                                                                }
                                                                                //case 3
                                                                                //cout&lt&lt"\nself left\n";
                                                                                 z->parent->color=black;
                                                                                 z->parent->parent->color=red;
                                                                                 Right_Rotate(z->parent->parent);
                                                                
                                                                }//case 2 and 3 ends
                                                             }  // first left if finish  
                         
                        else{
                             
                             if(z->parent->parent->left!=nil && z->parent->parent->left->color==red){
                                                                                //case 1                    
                                                                                 z->parent->color=black;
                                                                                 z->parent->parent->left->color=black;
                                                                                 z=z->parent->parent;                   
                                                                                 z->color=red;                   
                                                                                                    }//case 1 finishh
                                                           else{
                                                                                //case 2
                                                                                if(z==z->parent->left){Right_Rotate((z=z->parent));}
                                                                                //case 3
                                                                                 z->parent->color=black;
                                                                                 z->parent->parent->color=red;
                                                                                 Left_Rotate(z->parent->parent);
                                                                
                                                                }//case 2 and 3 ends
                             
                             }//else close 
                         
                         }//while close
           root->color=black;
           }     // Redify finish
           
       node* get_root(){return root;}
       
       node* Red_Black_Minimum(node *p){if(p->left!=nil){return Red_Black_Minimum(p->left);}else{ return p;}}//red black minimun clccose
    
    
     node* Red_Black_Succesor(node* p){
           
           if(p->right!=nil){return Red_Black_Minimum(p->right);}
           node *y=p;
           while(y!=nil && y==(y->parent)->right){ y=y->parent;  }
           return (y==nil?nil:y->parent);
           }//red black succesor cllose
      
       
       
       void Red_Black_Delete(node* p){
            
            node* x=nil,*y=nil;
            if(p->left==nil ||p->right==nil){y=p;}else{y=Red_Black_Succesor(p);}
            if(y->left!=nil){x=y->left;}else{x=y->right;}
            x->parent=y->parent;
            
            if(y->parent==nil){root=x;}
            else{if(y==y->parent->left){x->parent->left=x;}else{x->parent->right=x;}}
            if(y!=p){p->data=y->data;}
            if(y->color==black){Delete_Redify(x);}
            }//red black delete finish
    
      void Delete_Redify(node* p){
           
           node* w=nil;
           
           while(p!=root && p->color==black){
                         
                         if(p->parent->left==p){
                                                w=p->parent->right;
                                                //case 1
                                                if( w->color==red ){w->color=black;w->parent->color=red;Left_Rotate(w->parent);
                                                w=p->parent->right;}
                                                //case 1 ends
                                                else{
                                                     //case 2
                                                     if(w->left->color==black && w->right->color==black){
                                                                              
                                                                              w->color=red;
                                                                              p=p->parent; 
                                                                              }//case 2 ends
                                                     
                                                     else {//case 3
                                                          if(w->left->color==red && w->right->color==black){w->color=red;
                                                          w->left->color=black;Right_Rotate(w);w=p->parent->right;}
                                                          //case 4
                                                     w->color=p->parent->color;p->parent->color=black;w->right->color=black;Left_Rotate(w->parent);p=root;
                                                     }//case 3 4 ensd
                                                     }//else finish
                                                
                                                
                                                }//if finish
                         else{
                              w=p->parent->left;
                              //case 1
                              if(w->color==red){w->parent->color=red;w->color=black;Right_Rotate(p->parent);w=p->parent->left;}
                              //case 1 ends
                              else{//case 2
                                   if(w->left->color==black && w->right->color==black){
                                           w->color=red;p=p->parent;                 
                                                            
                                                            }//case 2 ends
                                   else{
                                        //case 3
                                        if(w->right->color==red && w->left->color==black){w->color=red;w->right->color=black;
                                        Left_Rotate(w);
                                        w=p->parent->left;}
                                        //case 4
                                        w->color=w->parent->color;w->parent->color=black;w->left->color=black;Right_Rotate(w->parent);p=root;
                                        //case 3 and 4 ends
                                        }
                                   
                                   }
                              
                              } 
                         
                         
                         }//while fingish
           
           p->color=black;
           
           } //delete redify finish       
      
       void Inorder_walk(node *p){
           if(p!=nil){ 
                       Inorder_walk(p->left);
                       cout&lt&lt" "&lt&ltp->data&lt&lt" ";
                       Inorder_walk(p->right);
                       }
           }//inorder walk finish
     
     void Preorder_walk(node *p){
           if(p!=nil){ 
                       cout&lt&lt" "&lt&ltp->data&lt&lt" ";
                       Preorder_walk(p->left);
                       Preorder_walk(p->right);
                       }
           }//preorder walk finish
     
      
      
      
      };

int main(){
   
    Red_Black_Tree rbt;
    
     int myint;
    do{
        cin>>myint;
        rbt.Red_Black_Insert(myint);
         rbt.Preorder_walk(rbt.get_root());cout&lt&ltendl&lt&lt"\n";
        }
        while(myint!=42);
        
        cout&lt&lt"\np\n"&lt&ltrbt.get_root()->min_gap;
    /*
    rbt.Inorder_walk(rbt.get_root());cout&lt&ltendl&lt&lt"k1\n";
    rbt.Red_Black_Delete(rbt.get_root());
     rbt.Preorder_walk(rbt.get_root());cout&lt&ltendl&lt&lt"k2\n";
    rbt.Red_Black_Delete(rbt.get_root());
     rbt.Preorder_walk(rbt.get_root());cout&lt&ltendl&lt&lt"3\n";
    rbt.Red_Black_Delete(rbt.get_root());
         rbt.Preorder_walk(rbt.get_root());cout&lt&ltendl&lt&lt"\n";
         */
    cout&lt&ltendl;system("pause");
    return 0;
    }
</p>
             <br><br>
<a href="mingap.cpp" download><button type="button">Download</button></a>            
						</div>
                    </div>
                </div>
            </div>
        </div>
    </div><div class="portfolio-modal modal fade" id="portfolioModal3" tabindex="-1" role="dialog" aria-hidden="true" >
        <div class="modal-content">
            <div class="close-modal" data-dismiss="modal">
                <div class="lr">
                    <div class="rl">
                    </div>
                </div>
            </div>
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-lg-offset-2">
                        <div class="modal-body">
                            <!-- Project Details Go Here -->
                             
                            <p class="item-intro text-muted">  <pre class='brush: cpp'>#include&ltiostream&gt
#include&ltvector&gt


using namespace std;

int merge_inversion(int p,int q,int r);

int count_inversion(int p,int  r);
vector&ltint&gt A;
 
int main()
{
    int n;
    cin>>n;A.push_back(0);
    for(int i=1;i&lt=n;i++){int y;cin>>y;A.push_back(y);
}
    cout&lt&ltendl&lt&ltcount_inversion(1,n)&lt&ltendl&lt&ltendl;
    cout&lt&ltendl&lt&lt"printing arrary"&lt&ltendl;
    for(int i=1;i&lt=n;i++){cout&lt&ltA[i]&lt&lt"\t";}
    cout&lt&ltendl;
        system("pause");
    return 0;
    }
    
    
 int count_inversion(int  p,int  r){
     int inversion=0;
     if(p<r){
int             q=(p+r)/2;
             inversion=inversion+count_inversion(p,q);
             inversion=inversion+count_inversion(q+1,r);
             inversion=inversion+merge_inversion(p,q,r);
             
             }
     return inversion;
     }   

int merge_inversion(int p,int q,int r){
    
    int n1=q-p+1;int n2=r-q;

vector&ltint&gt l1;
vector&ltint&gt l2;
l1.resize(n1+2);
l2.resize(n2+2);

    for(int i=1;i&lt=n1;i++){l1[i]=A[p+i-1];}
    for(int i=1;i&lt=n2;i++){l2[i]=A[q+i];}
    
    l1[n1+1]=99999970;
    l2[n2+1]=99999970;
    
    int i=1,j=1;
    
    int inversion=0;bool counts=false;
    
    for(int k=p;k&lt=r;k++){
            
            if(!counts && l2[j]<l1[i]){inversion = inversion+n1+1-i;counts=true;}
            if(l1[i]&lt=l2[j]){A[k]=l1[i];i++;}
            else{A[k]=l2[j];j++;counts=false;}
            }
    
    return inversion;
    
    }</p>
            <br><br>
<a href="count.cpp" download><button type="button">Download</button></a>             
						</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
  
            
    <!-- jQuery Version 1.11.0 -->
    <script src="js/jquery-1.11.0.js"></script>

    <!-- Bootstrap Core JavaScript -->
    <script src="js/bootstrap.min.js"></script>

    <!-- Plugin JavaScript -->
    <script src="http://cdnjs.cloudflare.com/ajax/libs/jquery-easing/1.3/jquery.easing.min.js"></script>
    <script src="js/classie.js"></script>
    <script src="js/cbpAnimatedHeader.js"></script>

    <!-- Contact Form JavaScript -->
    <script src="js/jqBootstrapValidation.js"></script>
    <script src="js/contact_me.js"></script>

    <!-- Custom Theme JavaScript -->
    <script src="js/agency.js"></script>

</body>

</html>

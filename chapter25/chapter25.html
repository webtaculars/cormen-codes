<!DOCTYPE html>
<html lang="en">

<head>
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
	<script> 
	$(function(){ // I use jQuery in this example
      
           function () { close(){$(".flip").click(function(){
    $(".panel").slideUp("slow");
  });
   });
   });
$(document).ready(function(){
  $(".flip").click(function(){
    $(".panel").slideToggle("slow");
  });
});
</script>
   

    <title>Chapter-25</title>
<link rel="stylesheet" href="css/style.css" type="text/css"/>
<style>
.list {list-style-type:none}
.list > li {display:inline;
			float:left;}
</style>
    <!-- Bootstrap Core CSS -->
    <link href="css/bootstrap.min.css" rel="stylesheet">

    <link href="css/agency.css" rel="stylesheet">


   
</head>

<body id="page-top" class="index">

    <!-- Navigation -->
    
<div class="header" style="background-image:url('head.jpg'); background-repeat:no-repeat; background-position:top;margin:0 auto;

	overflow:hidden;">
	<div class="wrap">
		<div style="">
		<center><h1><font size="100px"><a href="../index.html"><img src="intro.jpg"></a></font></h1><center>
		</div>
		<div class="cname" style="font-family: Arial black, Georgia, Serif">
			
         <center><h1><font type="Arial black">Chapter-25</h1></center>
		</div>	
		<div class="clear"><center><h2><font color="#346fa1">All Source Shortest Path</font></h2></center></div>
	</div>
</div>
   
 <div class="container" style="background-image:url('tail.jpg');background-repeat:no-repeat;background-position:top;margin:0 auto;

	overflow:hidden;margin-top:-50px">
    <section id="content" >
      <div class="inside">
        <br><br><center><h2>All Questions</h2></center>
        <div class="left" style="width:100%">
        <ul class="list"><br><br>
          <li style="margin-left:130px;width:23%"><img src="icon1.png">
            <h4><a href="#portfolioModal1" class="portfolio-link" data-toggle="modal">
                     Floyd warshall
                         </a></h4>
			

			<a href="floyd.cpp" style="margin-top:-50px" download>Download</a>
            <br/>
			<br>
			<br/>
			<br>
          </li>
          <li style="width:23%"><img src="icon1.png">
            <a href=""><h4><a href="#portfolioModal2" class="portfolio-link" data-toggle="modal">Fibonnaci</a></h4></a>
            <a href="fibonnaci.cpp" download>Download</a>
          <br/><br/>
			<br>
			<br>
		  </li>
          <li style="width:20%"><img src="icon1.png">
            <a href=""><h4><a href="#portfolioModal3" class="portfolio-link" data-toggle="modal">Johnson algorithm</a></h4></a>
            <a href="johnson.cpp" download>Download</a>
			<br/><br/>
			<br>
			<br>
          </li>
	
        </ul>
      </div>
	  
	   </div>
	  <br/>
	  <br/>
	  <br/>
	  <br/>
	  <br/>
	  <br/>
	  <br/>
	  <br/>
	  <br/>
	  <br/>
	  <br/>
	  <br/>
	  	  <center><p class="lf">Copyright &copy;  <a href="http://www.httpcart.com/">httpcart.com</a> - All Rights Reserved</p>
    <p class="rf">A product of <a href="http://www.httpcart.com/">httpcart.com</a></p></center>

      </div>
    </section>
	
</div>
    
                
                  
                    
                
           
   
    <!-- Portfolio Modals -->
    <!-- Use the modals below to showcase details about your portfolio projects! -->

    <!-- Portfolio Modal 1 -->
	
    <div class="portfolio-modal modal fade" id="portfolioModal1" tabindex="-1" role="dialog" aria-hidden="true" >
        <div class="modal-content">
            <div class="close-modal" data-dismiss="modal">
                <div class="lr">
                    <div class="rl">
                    </div>
                </div>
            </div>
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-lg-offset-2">
                        <div class="modal-body">
                            <!-- Project Details Go Here -->
                             
                            <p class="item-intro text-muted">  <pre class='brush: cpp'>#include&ltiostream&gt
#include&ltcmath&gt
#include&ltlist&gt
#include&ltstack&gt
#include&ltbitset&gt
#include&ltvector&gt
#include&ltstring&gt
#include&ltalgorithm&gt
#include &ltnew>
#include &ltmap&gt
#include&ltutility>
#define INF (1&lt&lt26)
#define null NULL
#define fi(sz) for(int i=0;i&ltsz;i++)
#define fj(sz) for(int j=0;j&ltsz;j++) 
#define pb push_back
#define all(v) (v).begin(),(v).end()
#define SP system("pause");
#define OP cout&lt&ltendl
typedef long long LL;
using namespace std;


class graph_alg{
      vector&ltvector&ltint > > v;
      vector&ltvector&ltint > > pd;
      vector&ltvector&ltbool > > tclosure;
      
      public:
      graph_alg(int n){v.resize(n,vector&ltint&gt (n,INF));tclosure.resize(n,vector&ltbool&gt (n,false));
      for(int i=0;&ltcstdlib&gt;i++){v[i][i]=0; tclosure[i][i]=true;}
      pd.resize(n,vector&ltint&gt (n,-1));
      }
      
int getelement(int i,int j){return v[i][j];}//get element finish

int getpredecessor(int i,int j){return pd[i][j];}

int min(int a,int b){return a&ltb?a:b;}//min finish

void floyd_warshall(){
     vector&ltint&gt temp=v;
     
     for(int k=0;k&ltv.size();k++){
             
             for(int i=0;i&ltv.size();i++){
                     
                     for(int j=0;j&ltv.size();j++){
                             if(temp[i][j]>temp[i][k]+temp[k][j]){
                                                          v[i][j]=temp[i][k]+temp[k][j];
                                                          pd[i][j]=k;        
                                                                  }
                             }//inner for finish
                     
                     }//mddle for finihs
             temp=v;
             }//outer for finish
     temp.clear();
     }//floyd warshall finish

void transitive_closure(){
     
     
     for(int k=0;k&ltv.size();k++){
             
             for(int i=0;i&ltv.size();i++){
                     
                     for(int j=0;j&ltv.size();j++){
                            tclosure[i][j]=tclosure[i][j]||(tclosure[i][k]&&tclosure[k][j]);
                             }//inner for finish
                     
                     }//mddle for finihs
             
             }//outer for finish
     
     }//transitive closure finish

void getdata(){
     cout&lt&lt"Enter no of edges : ";int e;cin>>e;OP;
     for(int i=0;i&lte;i++){
     cout&lt&lt"Enter starting vertex, end vertex and cost associated ";OP;
     int temp1,temp2,temp3;cin>>temp1>>temp2>>temp3;
     v[temp1][temp2]=temp3;
     pd[temp1][temp2]=temp1;
     tclosure[temp1][temp2]=true;
     
     }//for finish
     }//getdata finish
     
void print(int kk){
     OP;int n=v.size();
    for(int i=0;&ltcstdlib&gt;i++){
       for(int j=0;&ltcstdlib&gt;j++){
    switch(kk){
               case 0:
    cout&lt&ltv[i][j]&lt&lt"  ";break;
               case 1:
    cout&lt&ltpd[i][j]&lt&lt"  ";break;
               case 2:
    cout&lt&lttclosure[i][j]&lt&lt"  ";break;
}
    }OP;}
     };     
      };


int main(){
    
    int n; 
    cin>>n;
    graph_alg ga(n);
    ga.getdata();
    ga.floyd_warshall();
    ga.transitive_closure();
    ga.print(0);OP;
    ga.print(1);OP;
    ga.print(2);OP;
    SP;
    }

/*
5
9
0 1 3
0 2 8
0 4 -4
1 3 1
1 4 7
2 1 4
3 0 2 
3 2 -5
4 3 6
*/

//care for INF value

</p>
	<br><br>
<a href="floyd.cpp" download><button type="button">Download</button></a>	
                           
						</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
<div class="portfolio-modal modal fade" id="portfolioModal2" tabindex="-1" role="dialog" aria-hidden="true" >
        <div class="modal-content">
            <div class="close-modal" data-dismiss="modal">
                <div class="lr">
                    <div class="rl">
                    </div>
                </div>
            </div>
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-lg-offset-2">
                        <div class="modal-body">
                            <!-- Project Details Go Here -->
                             
                            <p class="item-intro text-muted">  <pre class='brush: cpp'>#include&ltiostream&gt
#include&ltcmath&gt
#include&ltlist&gt
#include&ltstack&gt
#include&ltutility>
#include&ltbitset&gt
#include&ltqueue>
#include&ltvector&gt
#include&ltstring&gt
#include&ltalgorithm&gt
#include &ltmap&gt
#define INF (1&lt&lt30)
#define null NULL
#define fi(sz) for(int i=0;i&ltsz;i++)
#define fj(sz) for(int j=0;j&ltsz;j++) 
#define pb push_back
#define all(v) (v).begin(),(v).end()
#define SP system("pause");
#define OP cout&lt&ltendl
#define WHITE 0
#define GRAY 1
#define BLACK 2
using namespace std;

struct node1{
       list&ltpair&ltnode1* ,int> > child; // prim node child
       int index;//vertex index
       int ds;//prim dista       
       node1* pd;//predecessor
       int fb;
       };
   
struct node{
node1* data;
int deg;
bool mark;
list&ltnode* > child;//fibnacci child
node* sib;
node* prev;
node* parent;
            };


class fib_heap{
      node* min;int num;list&ltnode* > root;
      public:
     
      fib_heap(){num=0;min=null;}
     
     void fib_consolidate(){
                   
                        int yl=num*log10(num)/log10(2);yl=yl+1;
                        node* ss=null;
          vector&ltnode* > v(yl,ss);
          while(!root.empty()){
                      node* x=root.front();
                      root.pop_front();
                      int degree=x->deg;
                      while(v[degree]!=null){
                              node* y=v[degree];
                              if(x->data->ds>y->data->ds){
                                                  swap(x,y);                    
                                                  }
                             fib_link(y,x);
                              v[degree]=null;
                              degree+=1;
                              }//inner while finish
                          v[degree]=x;
                          
                      }//while finish
          min=null;
          
          for(int i=0;i&ltv.size();i++){
                  if(v[i]!=null){root.push_back(v[i]);
                                 if(min==null || v[i]->data->ds&ltmin->data->ds){min=v[i];  }         
                                 }
                  }
          
          }//conso finish 
     
      
     void swap(node* &x,node* &y) {
           
          node* temp=x;
          x=y;
          y=temp;
          }//swap finish
       
      node* get_min(){return min;}//get min finsh
      
      void fib_extract_min(){
             
           node* z=min;
                      
           if(z!=null){
                      while(!z->child.empty()){
                                               node *temp=z->child.front();
                                               z->child.pop_front();
                                               fib_insert_ii(temp);
                                               root.push_back(temp);
                                               }
                      {
                       node* prev=z->prev;
                       node* next=z->sib;
                       prev->sib=next;
                       next->prev=prev;
                       min=next;
                       root.remove(z);
                       }
                       
                       if(z==z->sib){min=null;}
                       else{ 
                            
                             fib_consolidate();  }
                      num-=1;
                       }
           }//fin extract min 
      
      void fib_link(node* z,node* y){
             node* prev=z->prev;
                       node* next=z->sib;
                       prev->sib=next;
                       next->prev=prev;
                       z->parent=y;
                       if(!y->child.empty()){
                       z->sib=y->child.front();
                       y->child.front()->prev=z;
                       z->prev=y->child.back();
                       y->child.back()->sib=z;
                       }else{z->sib=null;z->prev=null;}
                       z->mark=false;
                    y->child.push_front(z);
                    y->deg+=1;   
           }//fib link close
      
     void cut(node* x,node* y){
          y->child.remove(x);
          fib_insert_ii(x);
          root.push_back(x);
          x->mark=false;
          }//cut finish
      
     void cascading_cut(node* y){
          node* z=y->parent;
          if(z!=null){
                      if(!y->mark){y->mark=true;}
                      else{
                           cut(y,z);
                           cascading_cut(z);
                           }
                      }
          }//ccut finish 
      
     void fib_decrease_key(node* x,int k){
          
          if(x->data->ds<k){cout&lt&lt"greater key error"; return ;}
          x->data->ds=k;
          node* y=x->parent;
          
          if(y!=null && y->data->ds > x->data->ds){
                     cut(x,y);
                     cascading_cut(y);
                     }
       
          if(x->data->ds&ltmin->data->ds){min=x;}         
         
          }//decrease key finish 
      
      void fib_delete(node* x){
           int p=min->data->ds-1;
           fib_decrease_key(x,p);
           fib_extract_min();
           }//fib delete finish
      
     bool empty(){if(min==null)return true;return false;};
    
     node* make_node(node1 *pp){
           node* temp=new node;
           temp->data=pp;
           temp->deg=0;
           temp->mark=false;
           temp->parent=null;
           temp->prev=null;
           temp->sib=null;
           temp->data->fb=(int)temp;
        return temp;   
           }//make node finish 
      
     void fib_insert(node1 *pp){
           node* p=make_node(pp);
          fib_insert_ii(p);
          if(min==null || min->data->ds>p->data->ds){min=p;}
          root.push_back(p);
          num+=1;
          }//fin insert finish 
      
     void fib_insert_ii(node* p){
          node* prev=null;
          if(min!=null){
          prev=min->prev;
          prev->sib=p;
          p->prev=prev;
          min->prev=p;
          p->sib=min;
          }else{p->prev=p;p->sib=p;}
          p->parent=null;
           }//insert ii  finish 
      
     list&ltnode* > gethead(){
                return  root;} 
      };
      
</p>
          <br><br>
 <a href="fibonnaci.cpp" download><button type="button">Download</button></a>						</div>
                    </div>
                </div>
            </div>
        </div>
    </div><div class="portfolio-modal modal fade" id="portfolioModal3" tabindex="-1" role="dialog" aria-hidden="true" >
        <div class="modal-content">
            <div class="close-modal" data-dismiss="modal">
                <div class="lr">
                    <div class="rl">
                    </div>
                </div>
            </div>
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-lg-offset-2">
                        <div class="modal-body">
                            <!-- Project Details Go Here -->
                             
                            <p class="item-intro text-muted">  <pre class='brush: cpp'>#include&ltiostream&gt
#include&ltcmath&gt
#include&ltlist&gt
#include&ltstack&gt
#include&ltutility>
#include&ltbitset&gt
#include&ltqueue>
#include&ltvector&gt
#include&ltstring&gt
#include&ltalgorithm&gt
#include &ltmap&gt
#define INF (1&lt&lt26)
#define null NULL
#define fi(sz) for(int i=0;i&ltsz;i++)
#define fj(sz) for(int j=0;j&ltsz;j++) 
#define pb push_back
#define all(v) (v).begin(),(v).end()
#define SP system("pause");
#define OP cout&lt&ltendl
#define WHITE 0
#define GRAY 1
#define BLACK 2
using namespace std;
#include "fibonacci.cpp"

struct pairs{
       int u;
       int v;
       int cost;
       };
    
class graph_alg{
vector&ltnode1* > v;int time; 
vector&ltpair&ltpair&ltint,int&gt ,int> > gmatrix;
vector&ltvector&ltint&gt  > ans;
vector&ltpairs> edge; 
fib_heap *fh;
public:
      graph_alg(int n,fib_heap gg){fh=&gg;v.resize(n,null);time=0;ans.resize(n,vector&ltint&gt (n,INF));
      for(int i=0;&ltcstdlib&gt;i++)ans[i][i]=0;
      }

      node1* getelement(int i){return v[i];}
      int getanswer(int i,int j){return ans[i][j];}
       
void print_vector(vector&ltnode1* > &b){
     OP&lt&lt" IN PRINT VECTOR \nvector value :";
     for(int i=0;i&ltb.size();i++){
     OP&lt&ltb[i]->index&lt&lt" -> "&lt&ltb[i]->ds;
   //   cout&lt&lt" child ";
   //  for(list&ltpair&ltnode1* ,int> > :: iterator it=b[i]->child.begin();it!=b[i]->child.end();it++){
     //            cout&lt&lt"  "&lt&lt(*it).first->index&lt&lt" -> "&lt&lt(*it).second;OP;
       //                     }
     }
     OP;
     }//print vector finish

void data_set(int ik,vector&ltnode1* > &vv){
     for(int i=0;i&ltvv.size();i++){
                                    vv[i]->ds=vv[i]->ds+v[i]->ds-v[ik]->ds;
                                    ans[ik][i]=vv[i]->ds;
             }//outer for finihs
     }//data set finish
 

void johnson_algorithm(){
     
     node1* temp=new node1;temp->ds=0;temp->index=v.size();temp->pd=null;temp->fb=0;
        for(int i=0;i&ltv.size();i++){temp->child.push_back(make_pair(v[i],0));}
        v.push_back(temp);
          
     if(!bellman_ford(v.back(),v)){
                                       cout&lt&lt" contain negative weight cycle";return ;
                                       }//fi
     
    
      v.pop_back();
      
      for(int i=0;i&ltv.size();i++){
              for(list&ltpair&ltnode1* ,int> >:: iterator it=v[i]->child.begin();it!=v[i]->child.end();it++){
                                   (*it).second=(*it).second+v[i]->ds-(*it).first->ds;
                                   }//inner for finish
              }//outer for finish
       
      vector&ltnode1* > use=make_copy(v,false);        
      
         for(int i=0;i&ltuse.size();i++){
                 Dijkstra(use[i],use);
      //           print_vector(use);
                 data_set(i,use);
       
                 data_copy(use,v);
                 }
     
     }//johnson finish 

void data_copy(vector&ltnode1* > &source,vector&ltnode1* > &dest){
              
              for(int i=0;i&ltsource.size();i++){
                      copy_node(source[i],dest[i]);
                      copy_child(source[i],dest[i],dest);
                      }
              
              }//data copy finish 
 
vector&ltnode1* > make_copy(vector&ltnode1* > &tt,bool extra){
     
     vector&ltnode1* > a;
     
     for(int i=0;i&lttt.size();i++){
             node1* temp=new node1;
             copy_node(temp,tt[i]);
             a.push_back(temp);
             }
     
     for(int i=0;i&lttt.size();i++){
             copy_child(a[i],tt[i],a);
             }
        if(extra){node1* temp=new node1;temp->ds=0;temp->index=tt.size();temp->pd=null;temp->fb=0;
        for(int i=0;i&lta.size();i++){temp->child.push_back(make_pair(a[i],0));}
        a.push_back(temp);
        }
     return a;        
     }//make copy finish 

bool cycle_check(node1* index_v,int cost,node1* u){

   if(index_v->ds>u->ds+cost){return false;}
return true;
}//cycle check finish

void copy_node(node1* a,node1* b){
        a->ds=INF;
        a->index=b->index;
        a->fb=b->fb;
        a->pd=null;
  }//copy node1 finish

void copy_child(node1* a,node1* b,vector&ltnode1* > &c){
     
     for(list&ltpair&ltnode1* ,int> > :: iterator it=b->child.begin();it!=b->child.end();it++){
          a->child.push_back(make_pair(c[(*it).first->index],(*it).second));
           
           }//for finish
     
     }//copy child finish

 
void relax(node1* index_v,int cost,node1* u){

   if(index_v->ds>u->ds+cost){
                                 index_v->ds=u->ds+cost;index_v->pd=u;}

}//relax finish


bool bellman_ford(node1* source,vector&ltnode1* > &vv){

//cout&lt&lt" source "&lt&ltsource->index&lt&lt" -> "&lt&ltsource->child.size();OP;
source->ds=0;
vector&ltnode1* > a;
for(int i=0;i&ltvv.size();i++){
      node1* temp=new node1;
      temp->ds=vv[i]->ds;
      temp->index=i;
      temp->pd=null;
      a.push_back(temp);
        }
   
        
for(int k=0;k&ltvv.size()-1;k++){
        
for(int i=0;i&ltvv.size();i++){
         
            for(list&ltpair&ltnode1* ,int> >:: iterator it=vv[i]->child.begin();it!=vv[i]->child.end();it++){
                        relax((*it).first,(*it).second,a[i]);
                      
                    }//inner for
}//middle for
   
for(int i=0;i&ltvv.size();i++){
        a[i]->ds=vv[i]->ds;
        }  
}//outer for

for(int i=0;i&ltvv.size();i++){
            for(list&ltpair&ltnode1* ,int> >::iterator  it=vv[i]->child.begin();it!=vv[i]->child.end();it++){
                      
            if(!cycle_check((*it).first,(*it).second,vv[i])){return false;}
                     
                    }//inner for
   }//outer for

a.clear();   
return true;
}//bellman ford finish


void relax(node1* u,node1* vv,int cost){
     if(vv->ds>u->ds+cost){
                          fh->fib_decrease_key((node* )vv->fb,u->ds+cost);
                            }
     }//relax finish

void Dijkstra(node1* source,vector&ltnode1* > &vv){
     
     source->ds=0;
     for(int i=0;i&ltvv.size();i++){
             fh->fib_insert(vv[i]);
             }
     
     while(!fh->empty()){
                         node1 *x=fh->get_min()->data;
                         fh->fib_extract_min();
                     
                     for(list&ltpair&ltnode1* ,int> > :: iterator it=x->child.begin();it!=x->child.end();it++){
                                         relax(x,(*it).first,(*it).second); 
                                          }//for finish
                     
                     }//while finish 
     }//dijkstra finish

void make_graph(){
     get_data();
     for(int i=0;i&ltv.size();i++){

     cout&lt&lt"enter no. of edges connected to "&lt&lt(i)&lt&lt"th vertex,index and the edge cost";OP;
             int temp1;cin>>temp1;
             for(int j=0;j&lttemp1;j++){
                      int temp2,temp3;cin>>temp2>>temp3;;
                      make_link(i,temp2,temp3);
                     pairs temp;
                     temp.u=i;
                     temp.v=temp2;
                     temp.cost=temp3;
                     edge.push_back(temp);
                     }
             }
     }//make arbitrary graph

void make_link(int i,int j,int k){
     v[i]->child.push_back(make_pair(v[j],k));
     }//make link finish

node1* make_node(){
     node1* temp=new node1;
     temp->ds=INF;
     temp->pd=null;
     return temp;
     }//make node1 finish

node1* make_index(int i){
       
       node1* temp=make_node();
       temp->index=i;
       return temp;
}//make index finsh

void get_data(){
     cout&lt&lt"enter "&lt&ltv.size()&lt&lt" vertices value";OP;
     for(int i=0;i&ltv.size();i++){
             v[i]=make_index(i);
             }
     }//get data finish

};
int main(){
    cout&lt&lt"Enter No of vertices";OP;
    fib_heap fh;
    int n;cin>>n;
    graph_alg ga(n,fh);
    ga.make_graph();
    ga.johnson_algorithm();
    cout&lt&lt"node are: ";OP;
    for(int i=0;&ltcstdlib&gt;i++){for(int j=0;&ltcstdlib&gt;j++){cout&lt&ltga.getanswer(i,j)&lt&lt"  ";}OP;};
 
    OP;
    OP;SP;
    }
/*
5
3 1 3 2 8 4 -4
2 4 7 3 1
1 1 4 
2 0 2 2 -5
1 3 6
*/
</p>
            <br><br>
<a href="johnson.cpp" download><button type="button">Download</button></a>	               
						</div>
                    </div>
                </div>
            </div>
        </div>
    </div><div class="portfolio-modal modal fade" id="portfolioModal4" tabindex="-1" role="dialog" aria-hidden="true" >
        <div class="modal-content">
            <div class="close-modal" data-dismiss="modal">
                <div class="lr">
                    <div class="rl">
                    </div>
                </div>
            </div>
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-lg-offset-2">
                        <div class="modal-body">
                            <!-- Project Details Go Here -->
                             
                            <p class="item-intro text-muted">  <pre class='brush: cpp'>#include/&ltiostream&gt
#include&ltvector&gt


using namespace std;

int merge_inversion(int p,int q,int r);

int count_inversion(int p,int  r);
vector&ltint&gt A;
 
int main()
{
    int n;
    cin>>n;A.push_back(0);
    for(int i=1;i&lt=n;i++){int y;cin>>y;A.push_back(y);
}
    cout&lt&ltendl&lt&ltcount_inversion(1,n)&lt&ltendl&lt&ltendl;
    cout&lt&ltendl&lt&lt"printing arrary"&lt&ltendl;
    for(int i=1;i&lt=n;i++){cout&lt&ltA[i]&lt&lt"\t";}
    cout&lt&ltendl;
        system("pause");
    return 0;
    }
    
    
 int count_inversion(int  p,int  r){
     int inversion=0;
     if(p<r){
int             q=(p+r)/2;
             inversion=inversion+count_inversion(p,q);
             inversion=inversion+count_inversion(q+1,r);
             inversion=inversion+merge_inversion(p,q,r);
             
             }
     return inversion;
     }   

int merge_inversion(int p,int q,int r){
    
    int n1=q-p+1;int n2=r-q;

vector&ltint&gt l1;
vector&ltint&gt l2;
l1.resize(n1+2);
l2.resize(n2+2);

    for(int i=1;i&lt=n1;i++){l1[i]=A[p+i-1];}
    for(int i=1;i&lt=n2;i++){l2[i]=A[q+i];}
    
    l1[n1+1]=99999970;
    l2[n2+1]=99999970;
    
    int i=1,j=1;
    
    int inversion=0;bool counts=false;
    
    for(int k=p;k&lt=r;k++){
            
            if(!counts && l2[j]<l1[i]){inversion = inversion+n1+1-i;counts=true;}
            if(l1[i]&lt=l2[j]){A[k]=l1[i];i++;}
            else{A[k]=l2[j];j++;counts=false;}
            }
    
    return inversion;
    
    }</p>
             <br><br>
<a href="count.cpp" download><button type="button">Download</button></a>	              
						</div>
                    </div>
                </div>
            </div>
        </div>
    </div><div class="portfolio-modal modal fade" id="portfolioModal5" tabindex="-1" role="dialog" aria-hidden="true" >
        <div class="modal-content">
            <div class="close-modal" data-dismiss="modal">
                <div class="lr">
                    <div class="rl">
                    </div>
                </div>
            </div>
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-lg-offset-2">
                        <div class="modal-body">
                            <!-- Project Details Go Here -->
                             
                            <p class="item-intro text-muted">  <pre class='brush: cpp'>#include/&ltiostream&gt
#include&ltvector&gt


using namespace std;

int merge_inversion(int p,int q,int r);

int count_inversion(int p,int  r);
vector&ltint&gt A;
 
int main()
{
    int n;
    cin>>n;A.push_back(0);
    for(int i=1;i&lt=n;i++){int y;cin>>y;A.push_back(y);
}
    cout&lt&ltendl&lt&ltcount_inversion(1,n)&lt&ltendl&lt&ltendl;
    cout&lt&ltendl&lt&lt"printing arrary"&lt&ltendl;
    for(int i=1;i&lt=n;i++){cout&lt&ltA[i]&lt&lt"\t";}
    cout&lt&ltendl;
        system("pause");
    return 0;
    }
    
    
 int count_inversion(int  p,int  r){
     int inversion=0;
     if(p<r){
int             q=(p+r)/2;
             inversion=inversion+count_inversion(p,q);
             inversion=inversion+count_inversion(q+1,r);
             inversion=inversion+merge_inversion(p,q,r);
             
             }
     return inversion;
     }   

int merge_inversion(int p,int q,int r){
    
    int n1=q-p+1;int n2=r-q;

vector&ltint&gt l1;
vector&ltint&gt l2;
l1.resize(n1+2);
l2.resize(n2+2);

    for(int i=1;i&lt=n1;i++){l1[i]=A[p+i-1];}
    for(int i=1;i&lt=n2;i++){l2[i]=A[q+i];}
    
    l1[n1+1]=99999970;
    l2[n2+1]=99999970;
    
    int i=1,j=1;
    
    int inversion=0;bool counts=false;
    
    for(int k=p;k&lt=r;k++){
            
            if(!counts && l2[j]<l1[i]){inversion = inversion+n1+1-i;counts=true;}
            if(l1[i]&lt=l2[j]){A[k]=l1[i];i++;}
            else{A[k]=l2[j];j++;counts=false;}
            }
    
    return inversion;
    
    }</p>
            <br><br>
<a href="count.cpp" download><button type="button">Download</button></a>	               
						</div>
                    </div>
                </div>
            </div>
        </div>
    </div><div class="portfolio-modal modal fade" id="portfolioModal6" tabindex="-1" role="dialog" aria-hidden="true" >
        <div class="modal-content">
            <div class="close-modal" data-dismiss="modal">
                <div class="lr">
                    <div class="rl">
                    </div>
                </div>
            </div>
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-lg-offset-2">
                        <div class="modal-body">
                            <!-- Project Details Go Here -->
                             
                            <p class="item-intro text-muted">  <pre class='brush: cpp'>#include/&ltiostream&gt
#include&ltvector&gt


using namespace std;

int merge_inversion(int p,int q,int r);

int count_inversion(int p,int  r);
vector&ltint&gt A;
 
int main()
{
    int n;
    cin>>n;A.push_back(0);
    for(int i=1;i&lt=n;i++){int y;cin>>y;A.push_back(y);
}
    cout&lt&ltendl&lt&ltcount_inversion(1,n)&lt&ltendl&lt&ltendl;
    cout&lt&ltendl&lt&lt"printing arrary"&lt&ltendl;
    for(int i=1;i&lt=n;i++){cout&lt&ltA[i]&lt&lt"\t";}
    cout&lt&ltendl;
        system("pause");
    return 0;
    }
    
    
 int count_inversion(int  p,int  r){
     int inversion=0;
     if(p<r){
int             q=(p+r)/2;
             inversion=inversion+count_inversion(p,q);
             inversion=inversion+count_inversion(q+1,r);
             inversion=inversion+merge_inversion(p,q,r);
             
             }
     return inversion;
     }   

int merge_inversion(int p,int q,int r){
    
    int n1=q-p+1;int n2=r-q;

vector&ltint&gt l1;
vector&ltint&gt l2;
l1.resize(n1+2);
l2.resize(n2+2);

    for(int i=1;i&lt=n1;i++){l1[i]=A[p+i-1];}
    for(int i=1;i&lt=n2;i++){l2[i]=A[q+i];}
    
    l1[n1+1]=99999970;
    l2[n2+1]=99999970;
    
    int i=1,j=1;
    
    int inversion=0;bool counts=false;
    
    for(int k=p;k&lt=r;k++){
            
            if(!counts && l2[j]<l1[i]){inversion = inversion+n1+1-i;counts=true;}
            if(l1[i]&lt=l2[j]){A[k]=l1[i];i++;}
            else{A[k]=l2[j];j++;counts=false;}
            }
    
    return inversion;
    
    }</p>
             <br><br>
<a href="count.cpp" download><button type="button">Download</button></a>	              
						</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <!-- jQuery Version 1.11.0 -->
    <script src="js/jquery-1.11.0.js"></script>

    <!-- Bootstrap Core JavaScript -->
    <script src="js/bootstrap.min.js"></script>

    <!-- Plugin JavaScript -->
    <script src="http://cdnjs.cloudflare.com/ajax/libs/jquery-easing/1.3/jquery.easing.min.js"></script>
    <script src="js/classie.js"></script>
    <script src="js/cbpAnimatedHeader.js"></script>

    <!-- Contact Form JavaScript -->
    <script src="js/jqBootstrapValidation.js"></script>
    <script src="js/contact_me.js"></script>

    <!-- Custom Theme JavaScript -->
    <script src="js/agency.js"></script>

</body>

</html>
